commit 404fc9952350d40a0afc82f1468f295e3b787854
Author: ìž„ìˆ˜í˜„ <ish@innogrid.com>
Date:   Mon Aug 25 15:01:41 2025 +0900

    Add Azure Monitoring PoC

diff --git a/api-runtime/common-runtime/MonitoringManager.go b/api-runtime/common-runtime/MonitoringManager.go
new file mode 100644
index 00000000..51ca7aaf
--- /dev/null
+++ b/api-runtime/common-runtime/MonitoringManager.go
@@ -0,0 +1,195 @@
+// Cloud Control Manager's Rest Runtime of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// by CB-Spider Team, 2020.09.
+
+package commonruntime
+
+import (
+	"fmt"
+	ccm "github.com/cloud-barista/cb-spider/cloud-control-manager"
+	cres "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+	infostore "github.com/cloud-barista/cb-spider/info-store"
+	"strconv"
+)
+
+//================ Monitoring Handler
+
+func GetVMMetricData(connectionName string, nameID string, metricType cres.MetricType, periodMinute string, timeBeforeHour string) (*cres.MetricData, error) {
+	cblog.Info("call GetVMMetricData()")
+
+	// check empty and trim user inputs
+	connectionName, err := EmptyCheckAndTrim("connectionName", connectionName)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	nameID, err = EmptyCheckAndTrim("nameID", nameID)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	cldConn, err := ccm.GetCloudConnection(connectionName)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	vmHandler, err := cldConn.CreateVMHandler()
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	vmSPLock.RLock(connectionName, nameID)
+	defer vmSPLock.RUnlock(connectionName, nameID)
+
+	// (1) get IID(NameId)
+	var iidInfo VMIIDInfo
+	err = infostore.GetByConditions(&iidInfo, CONNECTION_NAME_COLUMN, connectionName, NAME_ID_COLUMN, nameID)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	// (2) get resource(SystemId)
+	vm, err := vmHandler.GetVM(getDriverIID(cres.IID{NameId: iidInfo.NameId, SystemId: iidInfo.SystemId}))
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	monitoringHandler, err := cldConn.CreateMonitoringHandler()
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	// (4) get monitoring info
+	info, err := monitoringHandler.GetVMMetricData(cres.VMMonitoringReqInfo{
+		VMIID:          vm.IId,
+		MetricType:     metricType,
+		IntervalMinute: periodMinute,
+		TimeBeforeHour: timeBeforeHour,
+	})
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	return &info, nil
+}
+
+func GetClusterNodeMetricData(connectionName string, clusterNameID string, nodeGroupNameID string, nodeNumber string, metricType cres.MetricType, periodMinute string, timeBeforeHour string) (*cres.MetricData, error) {
+	cblog.Info("call GetClusterNodeMetricData()")
+
+	// check empty and trim user inputs
+	connectionName, err := EmptyCheckAndTrim("connectionName", connectionName)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	clusterNameID, err = EmptyCheckAndTrim("clusterNameID", clusterNameID)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	nodeGroupNameID, err = EmptyCheckAndTrim("nodeGroupNameID", nodeGroupNameID)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	nodeNumber, err = EmptyCheckAndTrim("nodeNumber", nodeNumber)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	nodeNumberInt, err := strconv.Atoi(nodeNumber)
+	if err != nil || nodeNumberInt <= 0 {
+		errMsg := "Invalid node number " + nodeNumber
+		cblog.Error(errMsg)
+		return nil, fmt.Errorf(errMsg)
+	}
+
+	cldConn, err := ccm.GetCloudConnection(connectionName)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	clusterSPLock.RLock(connectionName, clusterNameID)
+	defer clusterSPLock.RUnlock(connectionName, clusterNameID)
+
+	cluserDriverIID, nodeGroupDriverIID, err := getClusterDriverIIDNodeGroupDriverIID(connectionName, clusterNameID, nodeGroupNameID)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	clusterHandler, err := cldConn.CreateClusterHandler()
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	clusterInfo, err := clusterHandler.GetCluster(cluserDriverIID)
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	var nodeGroupExist bool
+	var nodeNameId string
+
+	for _, nodeGroup := range clusterInfo.NodeGroupList {
+		if nodeGroup.IId.NameId == nodeGroupDriverIID.NameId {
+			if nodeNumberInt > len(nodeGroup.Nodes) {
+				errMsg := fmt.Sprintf("Node number %s is greater than the number of nodes (%d).", nodeNumber, len(nodeGroup.Nodes))
+				cblog.Error(errMsg)
+				return nil, fmt.Errorf(errMsg)
+			}
+
+			nodeNameId = nodeGroup.Nodes[nodeNumberInt-1].NameId
+
+			nodeGroupExist = true
+			break
+		}
+	}
+
+	if !nodeGroupExist {
+		errMsg := fmt.Sprintf("node group %s not exist", nodeGroupDriverIID.NameId)
+		cblog.Error(errMsg)
+		return nil, fmt.Errorf(errMsg)
+	}
+
+	monitoringHandler, err := cldConn.CreateMonitoringHandler()
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	// (4) get monitoring info
+	info, err := monitoringHandler.GetClusterNodeMetricData(cres.ClusterNodeMonitoringReqInfo{
+		ClusterIID:     cluserDriverIID,
+		NodeGroupID:    nodeGroupDriverIID,
+		NodeIID:        cres.IID{NameId: nodeNameId},
+		MetricType:     metricType,
+		IntervalMinute: periodMinute,
+		TimeBeforeHour: timeBeforeHour,
+	})
+	if err != nil {
+		cblog.Error(err)
+		return nil, err
+	}
+
+	return &info, nil
+}
diff --git a/api-runtime/rest-runtime/CBSpiderRuntime.go b/api-runtime/rest-runtime/CBSpiderRuntime.go
index be7464d8..29be7f86 100644
--- a/api-runtime/rest-runtime/CBSpiderRuntime.go
+++ b/api-runtime/rest-runtime/CBSpiderRuntime.go
@@ -467,6 +467,10 @@ func RunServer() {
 		{"GET", "/filesystem/:Name/accesssubnet", ListAccessSubnet},
 		{"DELETE", "/filesystem/:Name/accesssubnet", RemoveAccessSubnet},
 
+		//----------Monitoring Handler
+		{"GET", "/monitoring/vm/:VMName/:MetricType", GetVMMetricData},
+		{"GET", "/monitoring/clusternode/:ClusterName/:NodeGroupName/:NodeNumber/:MetricType", GetClusterNodeMetricData},
+
 		//----------Destory All Resources in a Connection
 		{"DELETE", "/destroy", Destroy},
 
diff --git a/api-runtime/rest-runtime/CBSpiderRuntime.go.orig b/api-runtime/rest-runtime/CBSpiderRuntime.go.orig
new file mode 100644
index 00000000..be7464d8
--- /dev/null
+++ b/api-runtime/rest-runtime/CBSpiderRuntime.go.orig
@@ -0,0 +1,981 @@
+// Rest Runtime Server of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// by CB-Spider Team, 2019.10.
+
+package restruntime
+
+import (
+	"bytes"
+	"crypto/subtle"
+	"crypto/tls"
+	"crypto/x509"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"log"
+	"path/filepath"
+	"strings"
+	"time"
+
+	"net/http"
+	"os"
+
+	cblogger "github.com/cloud-barista/cb-log"
+	cr "github.com/cloud-barista/cb-spider/api-runtime/common-runtime"
+	aw "github.com/cloud-barista/cb-spider/api-runtime/rest-runtime/admin-web"
+	infostore "github.com/cloud-barista/cb-spider/info-store"
+
+	"github.com/sirupsen/logrus"
+
+	// REST API (echo)
+	"github.com/labstack/echo/v4"
+	"github.com/labstack/echo/v4/middleware"
+	lblog "github.com/labstack/gommon/log"
+
+	// echo-swagger middleware
+	_ "github.com/cloud-barista/cb-spider/api"
+	echoSwagger "github.com/swaggo/echo-swagger"
+
+	"github.com/natefinch/lumberjack"
+)
+
+var cblog *logrus.Logger
+
+// @title CB-Spider REST API
+// @version latest
+// @description **ðŸ•·ï¸ [User Guide](https://github.com/cloud-barista/cb-spider/wiki/features-and-usages)**  **ðŸ•·ï¸ [API Guide](https://github.com/cloud-barista/cb-spider/wiki/REST-API-Examples)**
+
+// @contact.name API Support
+// @contact.url http://cloud-barista.github.io
+// @contact.email contact-to-cloud-barista@googlegroups.com
+
+// @license.name Apache 2.0
+// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
+
+// @host localhost:1024
+
+// @BasePath /spider
+
+// @schemes http
+
+// @securityDefinitions.basic BasicAuth
+
+func init() {
+	cblog = cblogger.GetLogger("CLOUD-BARISTA")
+	currentTime := time.Now()
+	cr.StartTime = currentTime.Format("2006.01.02 15:04:05 Mon")
+	cr.MiddleStartTime = currentTime.Format("2006.01.02.15:04:05")
+	cr.ShortStartTime = fmt.Sprintf("T%02d:%02d:%02d", currentTime.Hour(), currentTime.Minute(), currentTime.Second())
+
+	// REST and GO SERVER_ADDRESS since v0.4.4
+	cr.ServerIPorName = getServerIPorName("SERVER_ADDRESS")
+	cr.ServerPort = getServerPort("SERVER_ADDRESS")
+
+	// REST SERVICE_ADDRESS for AdminWeb since v0.4.4
+	cr.ServiceIPorName = getServiceIPorName("SERVICE_ADDRESS")
+	cr.ServicePort = getServicePort("SERVICE_ADDRESS")
+}
+
+// ex) {"POST", "/driver", registerCloudDriver}
+type route struct {
+	method, path string
+	function     echo.HandlerFunc
+}
+
+// JSON Simple message struct
+type SimpleMsg struct {
+	Message string `json:"message" validate:"required" example:"Any message" description:"A simple message to be returned by the API"`
+}
+
+//// CB-Spider Servcie Address Configuration
+////   cf)  https://github.com/cloud-barista/cb-spider/wiki/CB-Spider-Service-Address-Configuration
+
+// REST and GO SERVER_ADDRESS since v0.4.4
+
+// unset                           # default: like 'curl ifconfig.co':1024
+// SERVER_ADDRESS="1.2.3.4:3000"  # => 1.2.3.4:3000
+// SERVER_ADDRESS=":3000"         # => like 'curl ifconfig.co':3000
+// SERVER_ADDRESS="localhost"      # => localhost:1024
+// SERVER_ADDRESS="1.2.3.4:3000"        # => 1.2.3.4::3000
+func getServerIPorName(env string) string {
+
+	hostEnv := os.Getenv(env) // SERVER_ADDRESS or SERVICE_ADDRESS
+
+	if hostEnv == "" {
+		return "localhost"
+	}
+
+	// "1.2.3.4" or "localhost"
+	if !strings.Contains(hostEnv, ":") {
+		return hostEnv
+	}
+
+	strs := strings.Split(hostEnv, ":")
+	if strs[0] == "" { // ":31024"
+		return "localhost"
+	} else { // "1.2.3.4:31024" or "localhost:31024"
+		return strs[0]
+	}
+}
+
+func getServerPort(env string) string {
+	// default REST Service Port
+	servicePort := ":1024"
+
+	hostEnv := os.Getenv(env) // SERVER_ADDRESS or SERVICE_ADDRESS
+	if hostEnv == "" {
+		return servicePort
+	}
+
+	// "1.2.3.4" or "localhost"
+	if !strings.Contains(hostEnv, ":") {
+		return servicePort
+	}
+
+	// ":31024" or "1.2.3.4:31024" or "localhost:31024"
+	strs := strings.Split(hostEnv, ":")
+	servicePort = ":" + strs[1]
+
+	return servicePort
+}
+
+// unset  SERVER_ADDRESS => SERVICE_ADDRESS
+func getServiceIPorName(env string) string {
+	hostEnv := os.Getenv(env)
+	if hostEnv == "" {
+		return cr.ServerIPorName
+	}
+	return getServerIPorName(env)
+}
+
+// unset  SERVER_ADDRESS => SERVICE_ADDRESS
+func getServicePort(env string) string {
+	hostEnv := os.Getenv(env)
+	if hostEnv == "" {
+		return cr.ServerPort
+	}
+	return getServerPort(env)
+}
+
+func RunServer() {
+
+	//======================================= setup routes
+	routes := []route{
+		//----------root
+		{"GET", "", aw.SpiderInfo},
+		{"GET", "/", aw.SpiderInfo},
+
+		//----------Swagger
+		{"GET", "/api", func(c echo.Context) error {
+			return c.Redirect(http.StatusMovedPermanently, "/spider/api/index.html")
+		}},
+		{"GET", "/api/", echoSwagger.EchoWrapHandler(echoSwagger.DocExpansion("none"))},
+		{"GET", "/api/*", echoSwagger.EchoWrapHandler(echoSwagger.DocExpansion("none"))},
+
+		//----------EndpointInfo
+		{"GET", "/endpointinfo", endpointInfo},
+
+		//---------- Server VersionInfo
+		{"GET", "/version", versionInfo},
+
+		//----------healthcheck
+		{"GET", "/healthcheck", healthCheck},
+		{"GET", "/health", healthCheck},
+		{"GET", "/ping", healthCheck},
+		{"GET", "/readyz", healthCheck},
+
+		//----------SystemStatsInfo Handler
+		{"GET", "/sysstats/system", FetchSystemInfo},
+		{"GET", "/sysstats/usage", FetchResourceUsage},
+
+		//----------CloudOS
+		{"GET", "/cloudos", ListCloudOS},
+
+		//----------CloudOSMetaInfo
+		{"GET", "/cloudos/metainfo/:CloudOSName", GetCloudOSMetaInfo},
+
+		//----------CloudDriver CapabilityInfo
+		{"GET", "/driver/capability", GetDriverCapability},
+
+		//----------CloudDriverInfo
+		{"POST", "/driver", RegisterCloudDriver},
+		{"POST", "/driver/upload", UploadCloudDriver},
+		{"GET", "/driver", ListCloudDriver},
+		{"GET", "/driver/:DriverName", GetCloudDriver},
+		{"DELETE", "/driver/:DriverName", UnRegisterCloudDriver},
+
+		//----------CredentialInfo
+		{"POST", "/credential", RegisterCredential},
+		{"GET", "/credential", ListCredential},
+		{"GET", "/credential/:CredentialName", GetCredential},
+		{"DELETE", "/credential/:CredentialName", UnRegisterCredential},
+
+		//----------RegionInfo
+		{"POST", "/region", RegisterRegion},
+		{"GET", "/region", ListRegion},
+		{"GET", "/region/:RegionName", GetRegion},
+		{"DELETE", "/region/:RegionName", UnRegisterRegion},
+
+		//----------ConnectionConfigInfo
+		{"POST", "/connectionconfig", CreateConnectionConfig},
+		{"GET", "/connectionconfig", ListConnectionConfig},
+		{"GET", "/connectionconfig/:ConfigName", GetConnectionConfig},
+		{"DELETE", "/connectionconfig/:ConfigName", DeleteConnectionConfig},
+		//-- for dashboard
+		{"GET", "/countconnectionconfig", CountAllConnections},
+		{"GET", "/countconnectionconfig/:ProviderName", CountConnectionsByProvider},
+
+		//-------------------------------------------------------------------//
+
+		//----------RegionZone Handler
+		{"GET", "/regionzone", ListRegionZone},
+		{"GET", "/regionzone/:Name", GetRegionZone},
+		{"GET", "/orgregion", ListOrgRegion},
+		{"GET", "/orgzone", ListOrgZone},
+		// by driverName & credentialName
+		{"GET", "/preconfig/regionzone", ListRegionZonePreConfig},
+		{"GET", "/preconfig/regionzone/:Name", GetRegionZonePreConfig},
+		{"GET", "/preconfig/orgregion", ListOrgRegionPreConfig},
+
+		//----------PriceInfo Handler
+		{"GET", "/productfamily/:RegionName", ListProductFamily},
+		{"GET", "/priceinfo/vm/:RegionName", GetVMPriceInfo},  // GET with a body for backward compatibility
+		{"POST", "/priceinfo/vm/:RegionName", GetVMPriceInfo}, // POST with a body for standard
+
+		//----------Image Handler
+		{"GET", "/vmimage", ListImage},
+		{"GET", "/vmimage/:Name", GetImage},
+
+		//----------VMSpec Handler
+		{"GET", "/vmspec", ListVMSpec},
+		{"GET", "/vmspec/:Name", GetVMSpec},
+		{"GET", "/vmorgspec", ListOrgVMSpec},
+		{"GET", "/vmorgspec/:Name", GetOrgVMSpec},
+
+		//----------VPC Handler
+		{"POST", "/regvpc", RegisterVPC},
+		{"DELETE", "/regvpc/:Name", UnregisterVPC},
+		{"POST", "/regsubnet", RegisterSubnet},
+		{"DELETE", "/regsubnet/:Name", UnregisterSubnet},
+
+		{"POST", "/vpc", CreateVPC},
+		{"GET", "/vpc", ListVPC},
+		{"GET", "/vpc/:Name", GetVPC},
+		{"DELETE", "/vpc/:Name", DeleteVPC},
+		//-- for subnet
+		{"POST", "/vpc/:VPCName/subnet", AddSubnet},
+		{"GET", "/vpc/:VPCName/subnet/:Name", GetSubnet},
+		{"DELETE", "/vpc/:VPCName/subnet/:SubnetName", RemoveSubnet},
+		{"DELETE", "/vpc/:VPCName/cspsubnet/:Id", RemoveCSPSubnet},
+		//-- for management
+		{"GET", "/allvpc", ListAllVPC},
+		{"GET", "/allvpcinfo", ListAllVPCInfo},
+		{"DELETE", "/cspvpc/:Id", DeleteCSPVPC},
+		//-- for dashboard
+		{"GET", "/countvpc", CountAllVPCs},
+		{"GET", "/countvpc/:ConnectionName", CountVPCsByConnection},
+		{"GET", "/countsubnet", CountAllSubnets},
+		{"GET", "/countsubnet/:ConnectionName", CountSubnetsByConnection},
+
+		//----------SecurityGroup Handler
+		{"GET", "/getsecuritygroupowner", GetSGOwnerVPC},
+		{"POST", "/getsecuritygroupowner", GetSGOwnerVPC},
+		{"POST", "/regsecuritygroup", RegisterSecurity},
+		{"DELETE", "/regsecuritygroup/:Name", UnregisterSecurity},
+
+		{"POST", "/securitygroup", CreateSecurity},
+		{"GET", "/securitygroup", ListSecurity},
+		{"GET", "/securitygroup/:Name", GetSecurity},
+		{"GET", "/securitygroup/vpc/:VPCName", ListVpcSecurity},
+		{"DELETE", "/securitygroup/:Name", DeleteSecurity},
+		//-- for rule
+		{"POST", "/securitygroup/:SGName/rules", AddRules},
+		{"DELETE", "/securitygroup/:SGName/rules", RemoveRules}, // no force option
+		// no CSP Option, {"DELETE", "/securitygroup/:SGName/csprules", RemoveCSPRules},
+		//-- for management
+		{"GET", "/allsecuritygroup", ListAllSecurity},
+		{"GET", "/allsecuritygroupinfo", ListAllSecurityGroupInfo},
+		{"DELETE", "/cspsecuritygroup/:Id", DeleteCSPSecurity},
+		//-- for dashboard
+		{"GET", "/countsecuritygroup", CountAllSecurityGroups},
+		{"GET", "/countsecuritygroup/:ConnectionName", CountSecurityGroupsByConnection},
+
+		//----------KeyPair Handler
+		{"POST", "/regkeypair", RegisterKey},
+		{"DELETE", "/regkeypair/:Name", UnregisterKey},
+
+		{"POST", "/keypair", CreateKey},
+		{"GET", "/keypair", ListKey},
+		{"GET", "/keypair/:Name", GetKey},
+		{"DELETE", "/keypair/:Name", DeleteKey},
+		//-- for management
+		{"GET", "/allkeypair", ListAllKey},
+		{"GET", "/allkeypairinfo", ListAllKeyPairInfo},
+		{"DELETE", "/cspkeypair/:Id", DeleteCSPKey},
+		//-- for dashboard
+		{"GET", "/countkeypair", CountAllKeys},
+		{"GET", "/countkeypair/:ConnectionName", CountKeysByConnection},
+		/*
+			//----------VNic Handler
+			{"POST", "/vnic", createVNic},
+			{"GET", "/vnic", listVNic},
+			{"GET", "/vnic/:VNicId", getVNic},
+			{"DELETE", "/vnic/:VNicId", deleteVNic},
+
+			//----------PublicIP Handler
+			{"POST", "/publicip", createPublicIP},
+			{"GET", "/publicip", listPublicIP},
+			{"GET", "/publicip/:PublicIPId", getPublicIP},
+			{"DELETE", "/publicip/:PublicIPId", deletePublicIP},
+		*/
+		//----------VM Handler
+		{"GET", "/getvmusingresources", GetVMUsingRS},
+		{"POST", "/getvmusingresources", GetVMUsingRS},
+		{"POST", "/regvm", RegisterVM},
+		{"DELETE", "/regvm/:Name", UnregisterVM},
+
+		{"POST", "/vm", StartVM},
+		{"GET", "/vm", ListVM},
+		{"GET", "/vm/:Name", GetVM},
+		{"DELETE", "/vm/:Name", TerminateVM},
+
+		{"GET", "/vmstatus", ListVMStatus},
+		{"GET", "/vmstatus/:Name", GetVMStatus},
+
+		{"GET", "/controlvm/:Name", ControlVM}, // suspend, resume, reboot
+		// only for AdminWeb
+		{"PUT", "/controlvm/:Name", ControlVM}, // suspend, resume, reboot
+
+		//-- for management
+		{"GET", "/allvm", ListAllVM},
+		{"GET", "/allvminfo", ListAllVMInfo},
+		{"DELETE", "/cspvm/:Id", TerminateCSPVM},
+		//-- for dashboard
+		{"GET", "/countvm", CountAllVMs},
+		{"GET", "/countvm/:ConnectionName", CountVMsByConnection},
+
+		//----------NLB Handler
+		{"GET", "/getnlbowner", GetNLBOwnerVPC},
+		{"POST", "/getnlbowner", GetNLBOwnerVPC},
+		{"POST", "/regnlb", RegisterNLB},
+		{"DELETE", "/regnlb/:Name", UnregisterNLB},
+
+		{"POST", "/nlb", CreateNLB},
+		{"GET", "/nlb", ListNLB},
+		{"GET", "/nlb/:Name", GetNLB},
+		{"DELETE", "/nlb/:Name", DeleteNLB},
+		//-- for vm
+		{"POST", "/nlb/:Name/vms", AddNLBVMs},
+		{"DELETE", "/nlb/:Name/vms", RemoveNLBVMs}, // no force option
+		{"PUT", "/nlb/:Name/listener", ChangeListener},
+		{"PUT", "/nlb/:Name/vmgroup", ChangeVMGroup},
+		{"PUT", "/nlb/:Name/healthchecker", ChangeHealthChecker},
+		{"GET", "/nlb/:Name/health", GetVMGroupHealthInfo},
+
+		//-- for management
+		{"GET", "/allnlb", ListAllNLB},
+		{"GET", "/allnlbinfo", ListAllNLBInfo},
+		{"DELETE", "/cspnlb/:Id", DeleteCSPNLB},
+		//-- for dashboard
+		{"GET", "/countnlb", CountAllNLBs},
+		{"GET", "/countnlb/:ConnectionName", CountNLBsByConnection},
+
+		//----------Disk Handler
+		{"POST", "/regdisk", RegisterDisk},
+		{"DELETE", "/regdisk/:Name", UnregisterDisk},
+
+		{"POST", "/disk", CreateDisk},
+		{"GET", "/disk", ListDisk},
+		{"GET", "/disk/:Name", GetDisk},
+		{"PUT", "/disk/:Name/size", IncreaseDiskSize},
+		{"DELETE", "/disk/:Name", DeleteDisk},
+		//-- for vm
+		{"PUT", "/disk/:Name/attach", AttachDisk},
+		{"PUT", "/disk/:Name/detach", DetachDisk},
+
+		//-- for management
+		{"GET", "/alldisk", ListAllDisk},
+		{"GET", "/alldiskinfo", ListAllDiskInfo},
+		{"DELETE", "/cspdisk/:Id", DeleteCSPDisk},
+		//-- for dashboard
+		{"GET", "/countdisk", CountAllDisks},
+		{"GET", "/countdisk/:ConnectionName", CountDisksByConnection},
+
+		//----------MyImage Handler
+		{"POST", "/regmyimage", RegisterMyImage},
+		{"DELETE", "/regmyimage/:Name", UnregisterMyImage},
+
+		{"POST", "/myimage", SnapshotVM},
+		{"GET", "/myimage", ListMyImage},
+		{"GET", "/myimage/:Name", GetMyImage},
+		{"DELETE", "/myimage/:Name", DeleteMyImage},
+
+		//-- for management
+		{"GET", "/allmyimage", ListAllMyImage},
+		{"GET", "/allmyimageinfo", ListAllMyImageInfo},
+		{"DELETE", "/cspmyimage/:Id", DeleteCSPMyImage},
+		//-- for dashboard
+		{"GET", "/countmyimage", CountAllMyImages},
+		{"GET", "/countmyimage/:ConnectionName", CountMyImagesByConnection},
+
+		//----------Cluster Handler
+		{"GET", "/getclusterowner", GetClusterOwnerVPC},
+		{"POST", "/getclusterowner", GetClusterOwnerVPC},
+		{"POST", "/regcluster", RegisterCluster},
+		{"DELETE", "/regcluster/:Name", UnregisterCluster},
+
+		{"POST", "/cluster", CreateCluster},
+		{"GET", "/cluster", ListCluster},
+		{"GET", "/cluster/:Name", GetCluster},
+		{"DELETE", "/cluster/:Name", DeleteCluster},
+		//-- for NodeGroup
+		{"POST", "/cluster/:Name/nodegroup", AddNodeGroup},
+		{"DELETE", "/cluster/:Name/nodegroup/:NodeGroupName", RemoveNodeGroup},
+		{"PUT", "/cluster/:Name/nodegroup/:NodeGroupName/onautoscaling", SetNodeGroupAutoScaling},
+		{"PUT", "/cluster/:Name/nodegroup/:NodeGroupName/autoscalesize", ChangeNodeGroupScaling},
+		{"PUT", "/cluster/:Name/upgrade", UpgradeCluster},
+		{"GET", "/cspvm/:Id", GetCSPVM},
+
+		//-- for management
+		{"GET", "/allcluster", ListAllCluster},
+		{"GET", "/allclusterinfo", ListAllClusterInfo},
+		{"DELETE", "/cspcluster/:Id", DeleteCSPCluster},
+		//-- for dashboard
+		{"GET", "/countcluster", CountAllClusters},
+		{"GET", "/countcluster/:ConnectionName", CountClustersByConnection},
+
+		//----------Tag Handler
+		{"POST", "/tag", AddTag},
+		{"GET", "/tag", ListTag},
+		{"GET", "/tag/:Key", GetTag},
+		{"DELETE", "/tag/:Key", RemoveTag},
+
+		//----------FileSystem Handler
+		// {"POST", "/regfilesystem", RegisterFileSystem},
+		// {"DELETE", "/regfilesystem/:Name", UnregisterFileSystem},
+
+		{"POST", "/filesystem", CreateFileSystem},
+		{"GET", "/filesystem", ListFileSystem},
+		{"GET", "/filesystem/:Name", GetFileSystem},
+		{"DELETE", "/filesystem/:Name", DeleteFileSystem},
+		// -- for AccessSubnet
+		{"POST", "/filesystem/:Name/accesssubnet", AddAccessSubnet},
+		{"GET", "/filesystem/:Name/accesssubnet", ListAccessSubnet},
+		{"DELETE", "/filesystem/:Name/accesssubnet", RemoveAccessSubnet},
+
+		//----------Destory All Resources in a Connection
+		{"DELETE", "/destroy", Destroy},
+
+		//----------checking TCP and UDP ports for NLB
+		{"GET", "/check/tcp", CheckTCPPort},
+		{"GET", "/check/udp", CheckUDPPort},
+
+		//-------------------------------------------------------------------//
+		//----------Additional Info
+		{"GET", "/cspresourcename/:Name", GetCSPResourceName},
+		{"GET", "/cspresourceinfo/:Name", GetCSPResourceInfo},
+
+		//----------AnyCall Handler
+		{"POST", "/anycall", AnyCall},
+
+		//----------WebMon Handler
+		{"GET", "/adminweb/vmmon", aw.VMMointoring},
+
+		//////////////////////////////////////////////////////////////
+		//------------------ Spiderlet Zone ------------------------
+
+		{"POST", "/spiderlet/anycall", SpiderletAnyCall},
+
+		//----------WebMon Handler
+		{"GET", "/adminweb/spiderlet/vmmon", aw.SpiderletVMMointoring},
+
+		//------------------ Spiderlet Zone ------------------------
+		//////////////////////////////////////////////////////////////
+
+		//-------------------------------------------------------------------//
+		//----------SPLock Info
+		{"GET", "/splockinfo", GetAllSPLockInfo},
+		//----------SSH RUN
+		{"POST", "/sshrun", SSHRun},
+
+		//----------AdminWeb Handler
+		{"GET", "/adminweb1", aw.Frame},
+		{"GET", "/adminweb1/", aw.Frame},
+		{"GET", "/adminweb/top", aw.Top},
+		{"GET", "/adminweb/log", aw.Log},
+
+		{"GET", "/adminweb", aw.MainPage},
+		{"GET", "/adminweb/", aw.MainPage},
+		{"GET", "/adminweb/left_menu", aw.LeftMenu},
+		{"GET", "/adminweb/body_frame", aw.BodyFrame},
+
+		{"GET", "/adminweb/dashboard", aw.Dashboard},
+
+		{"GET", "/adminweb/driver1", aw.Driver},
+		{"GET", "/adminweb/driver", aw.DriverManagement},
+
+		{"GET", "/adminweb/credential1", aw.Credential},
+		{"GET", "/adminweb/credential", aw.CredentialManagement},
+
+		{"GET", "/adminweb/region1", aw.Region},
+		{"GET", "/adminweb/region", aw.RegionManagement},
+
+		{"GET", "/adminweb/connectionconfig1", aw.Connectionconfig},
+		{"GET", "/adminweb/connectionconfig", aw.ConnectionManagement},
+
+		{"GET", "/adminweb/spiderinfo", aw.SpiderInfo},
+
+		{"GET", "/adminweb/sysstats", aw.SystemStatsInfoPage},
+
+		{"GET", "/adminweb/vpc/:ConnectConfig", aw.VPCSubnetManagement},
+		{"GET", "/adminweb/vpcmgmt/:ConnectConfig", aw.VPCMgmt},
+		{"GET", "/adminweb/securitygroup/:ConnectConfig", aw.SecurityGroupManagement},
+		{"GET", "/adminweb/securitygroupmgmt/:ConnectConfig", aw.SecurityGroupMgmt},
+		{"GET", "/adminweb/keypair/:ConnectConfig", aw.KeyPairManagement},
+		{"GET", "/adminweb/keypairmgmt/:ConnectConfig", aw.KeyPairMgmt},
+		{"GET", "/adminweb/vm/:ConnectConfig", aw.VMManagement},
+		{"GET", "/adminweb/vmmgmt/:ConnectConfig", aw.VMMgmt},
+		{"GET", "/adminweb/nlb/:ConnectConfig", aw.NLBManagement},
+		{"GET", "/adminweb/nlbmgmt/:ConnectConfig", aw.NLBMgmt},
+		{"GET", "/adminweb/disk/:ConnectConfig", aw.DiskManagement},
+		{"GET", "/adminweb/diskmgmt/:ConnectConfig", aw.DiskMgmt},
+		{"GET", "/adminweb/cluster/:ConnectConfig", aw.ClusterManagement},
+		{"GET", "/adminweb/clustermgmt/:ConnectConfig", aw.ClusterMgmt},
+		{"GET", "/adminweb/myimage/:ConnectConfig", aw.MyImageManagement},
+		{"GET", "/adminweb/myimagemgmt/:ConnectConfig", aw.MyImageMgmt},
+		{"GET", "/adminweb/vmimage/:ConnectConfig", aw.VMImage},
+		{"GET", "/adminweb/vmspec/:ConnectConfig", aw.VMSpec},
+		{"GET", "/adminweb/regionzone/:ConnectConfig", aw.RegionZone},
+		{"GET", "/adminweb/priceinfo/:ConnectConfig", aw.PriceInfoRequest},
+		{"GET", "/adminweb/priceinfotablelist/:ProductFamily/:RegionName/:ConnectConfig", aw.PriceInfoTableList},
+		// download price info with JSON file
+		{"GET", "/adminweb/priceinfo/download/:FileName", aw.DownloadPriceInfo},
+
+		{"GET", "/adminweb/s3/:ConnectConfig", aw.S3Management},
+
+		{"GET", "/adminweb/cmd-agent", aw.CmdAgent},
+		{"POST", "/adminweb/generate-cmd", aw.GenerateCmd},
+
+		{"GET", "/adminweb/calllog-analyzer", aw.CallLogAnalyzer},
+		{"POST", "/adminweb/analyze-logs", aw.AnalyzeLogs},
+		{"GET", "/adminweb/read-logs", aw.GetReadLogs},
+
+		//----------SSH WebTerminal Handler
+		{"GET", "/adminweb/sshwebterminal/ws", aw.HandleWebSocket},
+	}
+
+	// for Standard S3 API - Order matters! More specific routes should come first
+	s3Routes := []route{
+		{"GET", "/", ListS3Buckets},
+
+		// Bucket-level operations (with query parameters)
+		{"GET", "/:Name", GetS3Bucket}, // Handles ?versioning, ?cors, ?policy, ?location, ?versions, and list objects
+		{"GET", "/:Name/", GetS3Bucket},
+		{"HEAD", "/:Name", GetS3Bucket},
+		{"PUT", "/:Name", CreateS3Bucket}, // Handles bucket creation AND bucket config (redirects to GetS3Bucket)
+		{"DELETE", "/:Name", DeleteS3Bucket},
+
+		//--------- don't change the order of these routes
+		{"POST", "/:BucketName/:ObjectKey+", HandleS3BucketPost},
+		{"POST", "/:Name", HandleS3BucketPost},
+		{"POST", "/:Name/", HandleS3BucketPost},
+		//--------- don't change the order of these routes
+
+		// Object-level operations
+		{"PUT", "/:BucketName/:ObjectKey+", PutS3ObjectFromFile},
+		{"HEAD", "/:BucketName/:ObjectKey+", GetS3ObjectInfo},
+		{"GET", "/:BucketName/:ObjectKey+", DownloadS3Object},
+		{"DELETE", "/:BucketName/:ObjectKey+", DeleteS3Object},
+	}
+
+	//======================================= setup routes
+
+	// Run API Server
+	ApiServer(routes, s3Routes)
+
+}
+
+func RunTLSServer(certFile, keyFile, caCertFile string, port int) {
+	e := echo.New()
+	e.Logger.SetLevel(lblog.ERROR) // Set logging level to ERROR only
+
+	// Recovery middleware for handling panics
+	e.Use(middleware.Recover())
+
+	e.GET("/getcredentials/:ConnectionName", GetCloudDriverAndConnectionInfoTLS)
+
+	// Load CA certificate
+	caCert, err := ioutil.ReadFile(caCertFile)
+	if err != nil {
+		fmt.Println("Failed to read CA certificate:", err)
+		// return
+	}
+
+	// Set up CA certificate pool
+	caCertPool := x509.NewCertPool()
+	caCertPool.AppendCertsFromPEM(caCert)
+
+	// Configure TLS settings
+	tlsConfig := &tls.Config{
+		ClientCAs:          caCertPool,
+		ClientAuth:         tls.RequireAndVerifyClientCert,
+		MinVersion:         tls.VersionTLS12,
+		InsecureSkipVerify: false,
+	}
+
+	// Bind to localhost only (127.0.0.1), external clients cannot connect
+	address := fmt.Sprintf("127.0.0.1:%d", port)
+	server := &http.Server{
+		Addr:      address,
+		Handler:   e,
+		TLSConfig: tlsConfig,
+	}
+
+	fmt.Printf("[CB-Spider] TLS server running... https://%s\n", address)
+
+	// Start TLS server
+	err = server.ListenAndServeTLS(certFile, keyFile)
+	if err != nil {
+		fmt.Printf("[CB-Spider] Failed to start TLS server: %v\n", err)
+	}
+}
+
+type bodyDumpResponseWriter struct {
+	io.Writer
+	http.ResponseWriter
+}
+
+func (w *bodyDumpResponseWriter) Write(b []byte) (int, error) {
+	return w.Writer.Write(b)
+}
+
+// ================ REST API Server: setup & start
+func ApiServer(routes []route, s3Routes []route) {
+	e := echo.New()
+
+	// Middleware
+	e.Use(middleware.CORS())
+	e.Use(middleware.Logger())
+	e.Use(middleware.Recover())
+	// Remove trailing slash middleware
+	e.Pre(middleware.RemoveTrailingSlash())
+
+	// Custom logging for S3 API requests
+	e.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
+		return func(c echo.Context) error {
+			if strings.HasPrefix(c.Request().Header.Get("Authorization"), "AWS4-HMAC-SHA256") {
+				cblog.Infof("S3 API Request: %s %s", c.Request().Method, c.Request().URL.Path)
+				cblog.Debugf("Request Headers: %v", c.Request().Header)
+
+				// Capture the response body
+				resBody := new(bytes.Buffer)
+				mw := io.MultiWriter(c.Response().Writer, resBody)
+				writer := &bodyDumpResponseWriter{Writer: mw, ResponseWriter: c.Response().Writer}
+				c.Response().Writer = writer
+
+				err := next(c)
+
+				cblog.Debugf("Response Status: %d", c.Response().Status)
+				cblog.Debugf("Response Headers: %v", c.Response().Header())
+				if c.Response().Status < 300 {
+					cblog.Debugf("Response Body: %s", resBody.String())
+				}
+
+				return err
+			}
+			return next(c)
+		}
+	})
+
+	cbspiderRoot := os.Getenv("CBSPIDER_ROOT")
+
+	// for HTTP Access Log
+	e.Logger.SetOutput(&lumberjack.Logger{
+		Filename:   cbspiderRoot + "/log/http-access.log",
+		MaxSize:    10, // megabytes
+		MaxBackups: 10, // number of backups
+		MaxAge:     31, // days
+	})
+
+	API_USERNAME := os.Getenv("API_USERNAME")
+	API_PASSWORD := os.Getenv("API_PASSWORD")
+
+	// SkipAuthPaths defines paths to skip authentication
+	SkipAuthPaths := map[string]bool{
+		"/spider/version":     true,
+		"/spider/healthcheck": true,
+		"/spider/health":      true,
+		"/spider/ping":        true,
+		"/spider/readyz":      true,
+	}
+
+	if API_USERNAME != "" && API_PASSWORD != "" {
+		cblog.Info("**** Rest Auth Enabled ****")
+		e.Use(middleware.BasicAuthWithConfig(middleware.BasicAuthConfig{
+			Skipper: func(c echo.Context) bool {
+				return SkipAuthPaths[c.Path()]
+			},
+			Validator: func(username, password string, c echo.Context) (bool, error) {
+				// Be careful to use constant time comparison to prevent timing attacks
+				if subtle.ConstantTimeCompare([]byte(username), []byte(API_USERNAME)) == 1 &&
+					subtle.ConstantTimeCompare([]byte(password), []byte(API_PASSWORD)) == 1 {
+					return true, nil
+				}
+				return false, nil
+			},
+		}))
+	} else {
+		cblog.Info("**** Rest Auth Disabled ****")
+	}
+
+	for _, route := range routes {
+		// /driver => /spider/driver
+		route.path = "/spider" + route.path
+		switch route.method {
+		case "POST":
+			e.POST(route.path, route.function)
+		case "GET":
+			e.GET(route.path, route.function)
+		case "PUT":
+			e.PUT(route.path, route.function)
+		case "DELETE":
+			e.DELETE(route.path, route.function)
+
+		}
+	}
+
+	// Standard S3 API routes (root level)
+	for _, route := range s3Routes {
+		switch route.method {
+		case "GET":
+			e.GET(route.path, route.function)
+		case "HEAD":
+			e.HEAD(route.path, route.function)
+		case "PUT":
+			e.PUT(route.path, route.function)
+		case "POST":
+			e.POST(route.path, route.function)
+		case "DELETE":
+			e.DELETE(route.path, route.function)
+		}
+	}
+
+	// Standard S3 API routes with /spider prefix
+	for _, route := range s3Routes {
+		spiderPath := "/spider" + route.path
+		switch route.method {
+		case "GET":
+			e.GET(spiderPath, route.function)
+		case "HEAD":
+			e.HEAD(spiderPath, route.function)
+		case "PUT":
+			e.PUT(spiderPath, route.function)
+		case "POST":
+			e.POST(spiderPath, route.function)
+		case "DELETE":
+			e.DELETE(spiderPath, route.function)
+		}
+	}
+
+	// for spider logo
+	e.Static("/spider/adminweb/images", filepath.Join(cbspiderRoot, "api-runtime/rest-runtime/admin-web/images"))
+
+	// for admin-web
+	e.File("/spider/adminweb/html/priceinfo-filter-gen.html", cbspiderRoot+"/api-runtime/rest-runtime/admin-web/html/priceinfo-filter-gen.html")
+
+	// for WebTerminal
+	e.Static("/spider/adminweb/static", filepath.Join(cbspiderRoot, "api-runtime/rest-runtime/admin-web/static"))
+
+	e.HideBanner = true
+	e.HidePort = true
+
+	spiderBanner()
+
+	httpServerPort := cr.ServerPort
+	if cr.ServerIPorName == "localhost" || cr.ServerIPorName == "127.0.0.1" {
+		// Bind to localhost only (127.0.0.1), external clients cannot connect
+		httpServerPort = cr.ServerIPorName + cr.ServerPort
+	}
+
+	server := &http.Server{
+		Addr: httpServerPort,
+		//ReadTimeout:    6000 * time.Second, // Increase the maximum duration of reading the entire request
+		//WriteTimeout:   6000 * time.Second, // Increase the maximum duration of writing the entire response
+		//IdleTimeout:    6000 * time.Second, // Increase the maximum duration of idle keep-alive connections
+		MaxHeaderBytes: 500 * 1024 * 1024, // Increase the maximum header size allowed by the server
+		ErrorLog:       log.New(os.Stderr, "HTTP SERVER ERROR: ", log.LstdFlags),
+	}
+
+	if err := e.StartServer(server); err != nil {
+		cblog.Fatalf("Failed to start the server: %v", err)
+	}
+}
+
+// ================ Endpoint Info
+func endpointInfo(c echo.Context) error {
+	cblog.Info("call endpointInfo()")
+
+	endpointInfo := fmt.Sprintf("\n  <CB-Spider> Multi-Cloud Infrastructure Federation Framework\n")
+	adminWebURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/adminweb"
+	endpointInfo += fmt.Sprintf("     - AdminWeb: %s\n", adminWebURL)
+	swaggerURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/api"
+	endpointInfo += fmt.Sprintf("     - Swagger UI: %s\n", swaggerURL)
+
+	// gRPCServer := "grpc://" + cr.ServiceIPorName + cr.GoServicePort
+	// endpointInfo += fmt.Sprintf("     - Go   API: %s\n", gRPCServer)
+
+	return c.String(http.StatusOK, endpointInfo)
+}
+
+// ================ Version Info
+// func versionInfo(c echo.Context) error {
+// 	cblog.Info("call versionInfo()")
+
+// 	versionInfo := fmt.Sprintf("\n  <CB-Spider> Multi-Cloud Infrastructure Federation Framework\n")
+// 	versionInfo += fmt.Sprintf("     - Version: %s\n", ar.Version)
+// 	versionInfo += fmt.Sprintf("     - Git Commit SHA: %s\n", ar.CommitSHA)
+// 	versionInfo += fmt.Sprintf("     - Build Timestamp: %s\n", ar.BuildTime)
+// 	versionInfo += fmt.Sprintf("     - Server Started At: %s\n", cr.StartTime)
+
+//		return c.String(http.StatusOK, versionInfo)
+//	}
+//
+// VersionInfoResponse represents the response body for the versionInfo API.
+type VersionInfoResponse struct {
+	Version string `json:"Version" example:"CB-Spider v0.10.2-22"`
+}
+
+var spiderVersionInfo = VersionInfoResponse{}
+
+func SetVersionInfo(version string) {
+	spiderVersionInfo.Version = "CB-Spider " + version
+}
+
+// versionInfo godoc
+// @ID version-info
+// @Summary Get Version Information
+// @Description Retrieves the version information of CB-Spider.
+// @Tags [Version]
+// @Accept  json
+// @Produce  json
+// @Success 200 {object} VersionInfoResponse "Version information retrieved successfully"
+// @Failure 500 {object} SimpleMsg "Internal Server Error"
+// @Router /version [get]
+func versionInfo(c echo.Context) error {
+	cblog.Info("call versionInfo()")
+
+	return c.JSON(http.StatusOK, spiderVersionInfo)
+}
+
+// HealthCheckResponse represents the response body for the healthCheck API.
+type HealthCheckResponse struct {
+	Message string `json:"message" validate:"required" example:"CB-Spider is ready"`
+}
+
+// healthCheck godoc
+// @ID health-check-healthcheck
+// @Summary Perform Health Check
+// @Description Checks the health of CB-Spider service and its dependencies via /healthcheck endpoint. ðŸ•·ï¸ [[User Guide](https://github.com/cloud-barista/cb-spider/wiki/Readiness-Check-Guide)]
+// @Tags [Health Check]
+// @Accept  json
+// @Produce  json
+// @Success 200 {object} HealthCheckResponse "Service is ready"
+// @Failure 503 {object} SimpleMsg "Service Unavailable"
+// @Router /healthcheck [get]
+func healthCheckHealthCheck(c echo.Context) error {
+	return healthCheck(c)
+}
+
+// healthCheck godoc
+// @ID health-check-health
+// @Summary Perform Health Check
+// @Description Checks the health of CB-Spider service and its dependencies via /health endpoint. ðŸ•·ï¸ [[User Guide](https://github.com/cloud-barista/cb-spider/wiki/Readiness-Check-Guide)]
+// @Tags [Health Check]
+// @Accept  json
+// @Produce  json
+// @Success 200 {object} HealthCheckResponse "Service is ready"
+// @Failure 503 {object} SimpleMsg "Service Unavailable"
+// @Router /health [get]
+func healthCheckHealth(c echo.Context) error {
+	return healthCheck(c)
+}
+
+// healthCheck godoc
+// @ID health-check-ping
+// @Summary Perform Health Check
+// @Description Checks the health of CB-Spider service and its dependencies via /ping endpoint. ðŸ•·ï¸ [[User Guide](https://github.com/cloud-barista/cb-spider/wiki/Readiness-Check-Guide)]
+// @Tags [Health Check]
+// @Accept  json
+// @Produce  json
+// @Success 200 {object} HealthCheckResponse "Service is ready"
+// @Failure 503 {object} SimpleMsg "Service Unavailable"
+// @Router /ping [get]
+func healthCheckPing(c echo.Context) error {
+	return healthCheck(c)
+}
+
+// healthCheck godoc
+// @ID health-check-readyz
+// @Summary Perform Health Check
+// @Description Checks the health of CB-Spider service and its dependencies via /readyz endpoint. ðŸ•·ï¸ [[User Guide](https://github.com/cloud-barista/cb-spider/wiki/Readiness-Check-Guide)]
+// @Tags [Health Check]
+// @Accept  json
+// @Produce  json
+// @Success 200 {object} HealthCheckResponse "Service is ready"
+// @Failure 503 {object} SimpleMsg "Service Unavailable"
+// @Router /readyz [get]
+func healthCheckReadyz(c echo.Context) error {
+	return healthCheck(c)
+}
+
+func customRemoveTrailingSlash() echo.MiddlewareFunc {
+	return func(next echo.HandlerFunc) echo.HandlerFunc {
+		return func(c echo.Context) error {
+			req := c.Request()
+			url := req.URL
+			path := url.Path
+
+			if strings.HasPrefix(path, "/spider/api") {
+				return next(c)
+			}
+
+			if len(path) > 1 && strings.HasSuffix(path, "/") {
+				redirectPath := path[:len(path)-1]
+				if url.RawQuery != "" {
+					redirectPath += "?" + url.RawQuery
+				}
+				return c.Redirect(http.StatusMovedPermanently, redirectPath)
+			}
+
+			return next(c)
+		}
+	}
+}
+
+// Common health check logic
+func healthCheck(c echo.Context) error {
+	// check database connection
+	err := infostore.Ping()
+	if err != nil {
+		return echo.NewHTTPError(http.StatusServiceUnavailable, err.Error())
+	}
+
+	return c.JSON(http.StatusOK, map[string]string{"message": "CB-Spider is ready"})
+}
+
+func spiderBanner() {
+	fmt.Println("\n  <CB-Spider> Multi-Cloud Infrastructure Federation Framework")
+
+	// AdminWeb
+	adminWebURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/adminweb"
+	fmt.Printf("     - AdminWeb: %s\n", adminWebURL)
+
+	// Swagger
+	swaggerURL := "http://" + cr.ServiceIPorName + cr.ServicePort + "/spider/api"
+	fmt.Printf("     - Swagger UI: %s\n", swaggerURL)
+
+}
diff --git a/api-runtime/rest-runtime/MonitoringRest.go b/api-runtime/rest-runtime/MonitoringRest.go
new file mode 100644
index 00000000..b44940f7
--- /dev/null
+++ b/api-runtime/rest-runtime/MonitoringRest.go
@@ -0,0 +1,115 @@
+// Cloud Control Manager's Rest Runtime of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// by CB-Spider Team, 2020.
+
+package restruntime
+
+import (
+	cmrt "github.com/cloud-barista/cb-spider/api-runtime/common-runtime"
+	cres "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+
+	// REST API (echo)
+	"net/http"
+
+	"github.com/labstack/echo/v4"
+)
+
+//================ Monitoring Handler
+
+func GetVMMetricData(c echo.Context) error {
+	cblog.Info("call GetVMMetricData()")
+
+	var req struct {
+		ConnectionName string
+		IntervalMinute string
+		TimeBeforeHour string
+	}
+
+	if err := c.Bind(&req); err != nil {
+		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
+	}
+
+	// To support for Get-Query Param Type API
+	if req.ConnectionName == "" {
+		req.ConnectionName = c.QueryParam("ConnectionName")
+	}
+
+	strMetricType := c.Param("MetricType")
+	metricType := cres.StringMetricType(strMetricType)
+	if metricType == cres.Unknown {
+		return echo.NewHTTPError(http.StatusInternalServerError, "Invalid Metric Type")
+	}
+
+	if req.IntervalMinute == "" {
+		req.IntervalMinute = c.QueryParam("IntervalMinute")
+	}
+	if req.IntervalMinute == "" {
+		req.IntervalMinute = "1"
+	}
+
+	if req.TimeBeforeHour == "" {
+		req.TimeBeforeHour = c.QueryParam("TimeBeforeHour")
+	}
+	if req.TimeBeforeHour == "" {
+		req.TimeBeforeHour = "1"
+	}
+
+	// Call common-runtime API
+	result, err := cmrt.GetVMMetricData(req.ConnectionName, c.Param("VMName"), metricType, req.IntervalMinute, req.TimeBeforeHour)
+	if err != nil {
+		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
+	}
+
+	return c.JSON(http.StatusOK, result)
+}
+
+func GetClusterNodeMetricData(c echo.Context) error {
+	cblog.Info("call GetClusterNodeMetricData()")
+
+	var req struct {
+		ConnectionName string
+		IntervalMinute string
+		TimeBeforeHour string
+	}
+
+	if err := c.Bind(&req); err != nil {
+		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
+	}
+
+	// To support for Get-Query Param Type API
+	if req.ConnectionName == "" {
+		req.ConnectionName = c.QueryParam("ConnectionName")
+	}
+
+	strMetricType := c.Param("MetricType")
+	metricType := cres.StringMetricType(strMetricType)
+	if metricType == cres.Unknown {
+		return echo.NewHTTPError(http.StatusInternalServerError, "Invalid Metric Type")
+	}
+
+	if req.IntervalMinute == "" {
+		req.IntervalMinute = c.QueryParam("IntervalMinute")
+	}
+	if req.IntervalMinute == "" {
+		req.IntervalMinute = "1"
+	}
+
+	if req.TimeBeforeHour == "" {
+		req.TimeBeforeHour = c.QueryParam("TimeBeforeHour")
+	}
+	if req.TimeBeforeHour == "" {
+		req.TimeBeforeHour = "1"
+	}
+
+	// Call common-runtime API
+	result, err := cmrt.GetClusterNodeMetricData(req.ConnectionName, c.Param("ClusterName"), c.Param("NodeGroupName"), c.Param("NodeNumber"), metricType, req.IntervalMinute, req.TimeBeforeHour)
+	if err != nil {
+		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
+	}
+
+	return c.JSON(http.StatusOK, result)
+}
diff --git a/api/docs.go b/api/docs.go
index b1b0af9b..b0e122cd 100644
--- a/api/docs.go
+++ b/api/docs.go
@@ -10297,6 +10297,7 @@ const docTemplate = `{
                 "sg",
                 "keypair",
                 "vm",
+                "vmmonitoring",
                 "nlb",
                 "disk",
                 "myimage",
@@ -10312,6 +10313,7 @@ const docTemplate = `{
                 "SG",
                 "KEY",
                 "VM",
+                "VMMONITORING",
                 "NLB",
                 "DISK",
                 "MYIMAGE",
diff --git a/api/swagger.json b/api/swagger.json
index 9d728787..5939261b 100644
--- a/api/swagger.json
+++ b/api/swagger.json
@@ -10294,6 +10294,7 @@
                 "sg",
                 "keypair",
                 "vm",
+                "vmmonitoring",
                 "nlb",
                 "disk",
                 "myimage",
@@ -10309,6 +10310,7 @@
                 "SG",
                 "KEY",
                 "VM",
+                "VMMONITORING",
                 "NLB",
                 "DISK",
                 "MYIMAGE",
diff --git a/api/swagger.yaml b/api/swagger.yaml
index d91a7930..d3fdd92c 100644
--- a/api/swagger.yaml
+++ b/api/swagger.yaml
@@ -1040,6 +1040,7 @@ definitions:
     - sg
     - keypair
     - vm
+    - vmmonitoring
     - nlb
     - disk
     - myimage
@@ -1055,6 +1056,7 @@ definitions:
     - SG
     - KEY
     - VM
+    - VMMONITORING
     - NLB
     - DISK
     - MYIMAGE
diff --git a/cloud-control-manager/cloud-driver/call-log/calllogger.go b/cloud-control-manager/cloud-driver/call-log/calllogger.go
index a86bb428..295bf9e6 100644
--- a/cloud-control-manager/cloud-driver/call-log/calllogger.go
+++ b/cloud-control-manager/cloud-driver/call-log/calllogger.go
@@ -59,6 +59,7 @@ const (
 	MYIMAGE       RES_TYPE = "MYIMAGE"
 	NLB           RES_TYPE = "NETWORKLOADBALANCER"
 	TAG           RES_TYPE = "TAG"
+	MONITORING    RES_TYPE = "MONITORING"
 
 	//=========== PMKS: Provider-Managed K8S
 	CLUSTER RES_TYPE = "CLUSTER"
diff --git a/cloud-control-manager/cloud-driver/call-log/calllogger.go.orig b/cloud-control-manager/cloud-driver/call-log/calllogger.go.orig
new file mode 100644
index 00000000..a86bb428
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/call-log/calllogger.go.orig
@@ -0,0 +1,261 @@
+// Call-Log: calling logger of Cloud & VM in CB-Spider
+//           Referred to cb-log
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//      * CB-Spider: https://github.com/cloud-barista/cb-spider
+//      * cb-log: https://github.com/cloud-barista/cb-log
+//
+// load and set config file
+//
+// ref) https://github.com/go-yaml/yaml/tree/v3
+//      https://godoc.org/gopkg.in/yaml.v3
+//
+// by CB-Spider Team, 2020.09.
+
+package calllog
+
+import (
+	"fmt"
+	"net"
+	"os"
+	"reflect"
+	"strings"
+	"time"
+
+	calllogformatter "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/call-log/formatter"
+	"github.com/sirupsen/logrus"
+	"github.com/snowzach/rotatefilehook"
+)
+
+type CLOUD_OS string
+type RES_TYPE string
+
+const (
+	//=========== CloudOS (ref: cb-spider/cloud-driver-libs/cloudos.yaml)
+	AWS       CLOUD_OS = "AWS"
+	AZURE     CLOUD_OS = "AZURE"
+	GCP       CLOUD_OS = "GCP"
+	ALIBABA   CLOUD_OS = "ALIBABA"
+	TENCENT   CLOUD_OS = "TENCENT"
+	IBM       CLOUD_OS = "IBM"
+	OPENSTACK CLOUD_OS = "OPENSTACK"
+	NCP       CLOUD_OS = "NCP"
+	NHN       CLOUD_OS = "NHN"
+	KTCLASSIC CLOUD_OS = "KTCLASSIC"
+	KT        CLOUD_OS = "KT"
+	MOCK      CLOUD_OS = "MOCK"
+	CLOUDTWIN CLOUD_OS = "CLOUDTWIN"
+
+	//=========== ResourceType
+	REGIONZONE    RES_TYPE = "REGIONZONE"
+	PRICEINFO     RES_TYPE = "PRICEINFO"
+	VMIMAGE       RES_TYPE = "VMIMAGE"
+	VMSPEC        RES_TYPE = "VMSPEC"
+	VPCSUBNET     RES_TYPE = "VPC/SUBNET"
+	SECURITYGROUP RES_TYPE = "SECURITYGROUP"
+	VMKEYPAIR     RES_TYPE = "VMKEYPAIR"
+	DISK          RES_TYPE = "DISK"
+	VM            RES_TYPE = "VM"
+	MYIMAGE       RES_TYPE = "MYIMAGE"
+	NLB           RES_TYPE = "NETWORKLOADBALANCER"
+	TAG           RES_TYPE = "TAG"
+
+	//=========== PMKS: Provider-Managed K8S
+	CLUSTER RES_TYPE = "CLUSTER"
+
+	//=========== FileSystem
+	FILESYSTEM RES_TYPE = "FILESYSTEM"
+)
+
+type CALLLogger struct {
+	loggerName string
+	logrus     *logrus.Logger
+}
+
+// global var.
+var (
+	HostIPorName  string
+	callLogger    *CALLLogger
+	callFormatter *calllogformatter.Formatter
+	calllogConfig CALLLOGCONFIG
+)
+
+func init() {
+	HostIPorName = getHostIPorName()
+}
+
+func getHostIPorName() string {
+	addrs, err := net.InterfaceAddrs()
+	if err != nil {
+		logrus.Error(err)
+		hostName, err := os.Hostname()
+		if err != nil {
+			logrus.Error(err)
+		}
+		return hostName
+	}
+
+	for _, addr := range addrs {
+		if ipnet, ok := addr.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
+			if ipnet.IP.To4() != nil {
+				return ipnet.IP.String()
+			}
+		}
+	}
+
+	hostName, err := os.Hostname()
+	if err != nil {
+		logrus.Error(err)
+	}
+	return hostName
+}
+
+func GetLogger(loggerName string) *logrus.Logger {
+	if callLogger != nil {
+		return callLogger.logrus
+	}
+	callLogger = new(CALLLogger)
+	callLogger.loggerName = loggerName
+	callLogger.logrus = &logrus.Logger{
+		Level:     logrus.InfoLevel,
+		Out:       os.Stderr,
+		Hooks:     make(logrus.LevelHooks),
+		Formatter: getFormatter(loggerName),
+	}
+
+	// set config.
+	setup(loggerName)
+	return callLogger.logrus
+}
+
+func setup(loggerName string) {
+	calllogConfig = GetConfigInfos()
+	callLogger.logrus.SetReportCaller(true)
+
+	if calllogConfig.CALLLOG.LOOPCHECK {
+		SetLevel(calllogConfig.CALLLOG.LOGLEVEL)
+		go levelSetupLoop(loggerName)
+	} else {
+		SetLevel(calllogConfig.CALLLOG.LOGLEVEL)
+	}
+
+	if calllogConfig.CALLLOG.LOGFILE {
+		setRotateFileHook(loggerName, &calllogConfig)
+	}
+
+	if !calllogConfig.CALLLOG.CONSOLE {
+		devNull, err := os.OpenFile(os.DevNull, os.O_WRONLY, 0)
+		if err != nil {
+			logrus.Fatalf("Failed to open os.DevNull: %v", err)
+		}
+		callLogger.logrus.SetOutput(devNull)
+	} else {
+		callLogger.logrus.SetOutput(os.Stderr)
+	}
+}
+
+// Now, this method is busy wait.
+// @TODO must change this  with file watch&event.
+// ref) https://github.com/fsnotify/fsnotify/blob/master/example_test.go
+func levelSetupLoop(loggerName string) {
+	for {
+		calllogConfig = GetConfigInfos()
+		SetLevel(calllogConfig.CALLLOG.LOGLEVEL)
+		time.Sleep(time.Second * 2)
+	}
+}
+
+func setRotateFileHook(loggerName string, logConfig *CALLLOGCONFIG) {
+	level, _ := logrus.ParseLevel(logConfig.CALLLOG.LOGLEVEL)
+
+	rotateFileHook, err := rotatefilehook.NewRotateFileHook(rotatefilehook.RotateFileConfig{
+		Filename:   logConfig.LOGFILEINFO.FILENAME,
+		MaxSize:    logConfig.LOGFILEINFO.MAXSIZE, // megabytes
+		MaxBackups: logConfig.LOGFILEINFO.MAXBACKUPS,
+		MaxAge:     logConfig.LOGFILEINFO.MAXAGE, //days
+		Level:      level,
+		Formatter:  getFormatter(loggerName),
+	})
+
+	if err != nil {
+		logrus.Fatalf("Failed to initialize file rotate hook: %v", err)
+	}
+	callLogger.logrus.AddHook(rotateFileHook)
+}
+
+func SetLevel(strLevel string) {
+	err := checkLevel(strLevel)
+	if err != nil {
+		logrus.Errorf("Failed to set log level: %v", err)
+	}
+	level, _ := logrus.ParseLevel(strLevel)
+	callLogger.logrus.SetLevel(level)
+}
+
+func checkLevel(lvl string) error {
+	switch strings.ToLower(lvl) {
+	case "error":
+		return nil
+	case "info":
+		return nil
+	}
+	return fmt.Errorf("not a valid calllog Level: %q", lvl)
+}
+
+func GetLevel() string {
+	return callLogger.logrus.GetLevel().String()
+}
+
+func getFormatter(loggerName string) *calllogformatter.Formatter {
+
+	if callFormatter != nil {
+		return callFormatter
+	}
+	callFormatter = &calllogformatter.Formatter{
+		TimestampFormat: "2006-01-02 15:04:05",
+		LogFormat:       "[" + loggerName + "].[" + HostIPorName + "] %time% (%weekday%) %func% - %msg%\n",
+	}
+	return callFormatter
+}
+
+// =========================
+type CLOUDLOGSCHEMA struct {
+	CloudOS      CLOUD_OS // ex) AWS | AZURE | ALIBABA | GCP | OPENSTACK | CLOUDTWIN | NCP | MOCK | IBM
+	RegionZone   string   // ex) us-east1/us-east1-c
+	ResourceType RES_TYPE // ex) VMIMAGE | VMSPEC | VPCSUBNET | SECURITYGROUP | VMKEYPAIR | VM
+	ResourceName string   // ex) vpc-01
+	CloudOSAPI   string   // ex) CreateKeyPair()
+	ElapsedTime  string   // ex) 2.0201 (sec)
+	ErrorMSG     string   // if success, ""
+}
+
+/* TBD or Do not support.
+type VMLOGSCHEMA struct {
+}
+*/
+
+func Start() time.Time {
+	return time.Now()
+}
+
+func Elapsed(start time.Time) string {
+	return fmt.Sprintf("%.4f", time.Since(start).Seconds())
+}
+
+func String(logInfo interface{}) string {
+	t := reflect.TypeOf(logInfo)
+	v := reflect.ValueOf(logInfo)
+
+	msg := ""
+	for idx := 0; idx < t.NumField(); idx++ {
+		typeOne := t.Field(idx)
+		one := v.Field(idx)
+		if idx < (t.NumField() - 1) {
+			msg += fmt.Sprintf("\"%s\" : \"%s\", ", typeOne.Name, one)
+		} else {
+			msg += fmt.Sprintf("\"%s\" : \"%s\"", typeOne.Name, one)
+		}
+	}
+
+	return msg
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/alibaba/connect/AlibabaCloudConnection.go b/cloud-control-manager/cloud-driver/drivers/alibaba/connect/AlibabaCloudConnection.go
index f2a08d54..3c2066ce 100644
--- a/cloud-control-manager/cloud-driver/drivers/alibaba/connect/AlibabaCloudConnection.go
+++ b/cloud-control-manager/cloud-driver/drivers/alibaba/connect/AlibabaCloudConnection.go
@@ -188,3 +188,7 @@ func (cloudConn *AlibabaCloudConnection) CreateTagHandler() (irs.TagHandler, err
 	handler := alirs.AlibabaTagHandler{cloudConn.Region, cloudConn.VMClient, cloudConn.Cs2015Client, cloudConn.VpcClient, cloudConn.NLBClient, cloudConn.NasClient}
 	return &handler, nil
 }
+
+func (cloudConn *AlibabaCloudConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, errors.New("Alibaba Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/alibaba/connect/AlibabaCloudConnection.go.orig b/cloud-control-manager/cloud-driver/drivers/alibaba/connect/AlibabaCloudConnection.go.orig
new file mode 100644
index 00000000..f2a08d54
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/drivers/alibaba/connect/AlibabaCloudConnection.go.orig
@@ -0,0 +1,190 @@
+// Alibaba Driver of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// This is Alibaba Driver.
+//
+// by CB-Spider Team, 2022.09.
+
+package connect
+
+import (
+	cs2015 "github.com/alibabacloud-go/cs-20151215/v4/client"
+	ecs2014 "github.com/alibabacloud-go/ecs-20140526/v4/client"
+	vpc2016 "github.com/alibabacloud-go/vpc-20160428/v6/client"
+	bssopenapi "github.com/aliyun/alibaba-cloud-sdk-go/services/bssopenapi"
+	"github.com/aliyun/alibaba-cloud-sdk-go/services/ecs"
+	"github.com/aliyun/alibaba-cloud-sdk-go/services/nas"
+	"github.com/aliyun/alibaba-cloud-sdk-go/services/slb"
+	"github.com/aliyun/alibaba-cloud-sdk-go/services/vpc"
+	cblog "github.com/cloud-barista/cb-log"
+	alirs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/drivers/alibaba/resources"
+	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
+	irs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+	"github.com/sirupsen/logrus"
+
+	"errors"
+)
+
+var cblogger *logrus.Logger
+
+func init() {
+	// cblog is a global variable.
+	cblogger = cblog.GetLogger("CB-SPIDER")
+}
+
+type AlibabaCloudConnection struct {
+	CredentialInfo idrv.CredentialInfo
+	Region         idrv.RegionInfo
+
+	VMClient      *ecs.Client
+	KeyPairClient *ecs.Client
+	ImageClient   *ecs.Client
+	//PublicIPClient      *vpc.Client
+	SecurityGroupClient *ecs.Client
+	//VNetClient          *vpc.Client
+	VpcClient *vpc.Client
+	//VNicClient          *ecs.Client
+	SubnetClient     *vpc.Client
+	VmSpecClient     *ecs.Client
+	NLBClient        *slb.Client
+	DiskClient       *ecs.Client
+	MyImageClient    *ecs.Client
+	RegionZoneClient *ecs.Client
+	FileSystemClient *nas.Client
+	NasClient        *nas.Client
+
+	Vpc2016Client *vpc2016.Client
+	Cs2015Client  *cs2015.Client
+	Ecs2014Client *ecs2014.Client
+	BssClient     *bssopenapi.Client
+}
+
+// CreateFileSystemHandler implements connect.CloudConnection.
+func (cloudConn *AlibabaCloudConnection) CreateFileSystemHandler() (irs.FileSystemHandler, error) {
+	cblogger.Info("Alibaba Cloud Driver: called CreateFileSystemHandler()!")
+	fileSystemHandler := alirs.AlibabaFileSystemHandler{Region: cloudConn.Region, Client: cloudConn.FileSystemClient, TagHandler: &alirs.AlibabaTagHandler{Region: cloudConn.Region, Client: cloudConn.VMClient, CsClient: cloudConn.Cs2015Client, VpcClient: cloudConn.VpcClient, SlbClient: cloudConn.NLBClient, NasClient: cloudConn.NasClient}}
+	return &fileSystemHandler, nil
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateRegionZoneHandler() (irs.RegionZoneHandler, error) {
+	//regionZoneHandler := alirs.AlibabaRegionZoneHandler{Region: cloudConn.Region, Client: cloudConn.RegionZoneClient}
+	regionZoneHandler := alirs.AlibabaRegionZoneHandler{Region: cloudConn.Region, Client: cloudConn.RegionZoneClient}
+	return &regionZoneHandler, nil
+}
+
+/*
+	func (cloudConn *AlibabaCloudConnection) CreateVNetworkHandler() (irs.VNetworkHandler, error) {
+		cblogger.Info("Alibaba Cloud Driver: called CreateVNetworkHandler()!")
+		vNetHandler := alirs.AlibabaVNetworkHandler{cloudConn.Region, cloudConn.VNetClient}
+		return &vNetHandler, nil
+	}
+*/
+func (cloudConn *AlibabaCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) {
+	cblogger.Info("Alibaba Cloud Driver: called CreateVPCHandler()!")
+	vpcHandler := alirs.AlibabaVPCHandler{cloudConn.Region, cloudConn.VpcClient}
+	return &vpcHandler, nil
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateImageHandler() (irs.ImageHandler, error) {
+	cblogger.Info("Alibaba Cloud Driver: called CreateImageHandler()!")
+	imageHandler := alirs.AlibabaImageHandler{cloudConn.Region, cloudConn.ImageClient}
+	return &imageHandler, nil
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) {
+	cblogger.Info("Alibaba Cloud Driver: called CreateSecurityHandler()!")
+	sgHandler := alirs.AlibabaSecurityHandler{cloudConn.Region, cloudConn.SecurityGroupClient}
+	return &sgHandler, nil
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) {
+	cblogger.Info("Alibaba Cloud Driver: called CreateKeyPairHandler()!")
+	keyPairHandler := alirs.AlibabaKeyPairHandler{cloudConn.Region, cloudConn.KeyPairClient}
+	return &keyPairHandler, nil
+}
+
+/*
+func (cloudConn *AlibabaCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
+	cblogger.Info("Alibaba Cloud Driver: called CreateVNicHandler()!")
+	//vNicHandler := alirs.AlibabaVNicHandler{cloudConn.Region, cloudConn.VNicClient, cloudConn.SubnetClient}
+	vNicHandler := alirs.AlibabaVNicHandler{cloudConn.Region, cloudConn.VNicClient}
+	return &vNicHandler, nil
+}
+*/
+
+/*
+func (cloudConn *AlibabaCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
+	cblogger.Info("Alibaba Cloud Driver: called CreatePublicIPHandler()!")
+	publicIPHandler := alirs.AlibabaPublicIPHandler{cloudConn.Region, cloudConn.PublicIPClient}
+	return &publicIPHandler, nil
+}
+*/
+
+func (cloudConn *AlibabaCloudConnection) CreateVMHandler() (irs.VMHandler, error) {
+	cblogger.Info("Alibaba Cloud Driver: called CreateVMHandler()!")
+	vmHandler := alirs.AlibabaVMHandler{cloudConn.Region, cloudConn.VMClient, cloudConn.VpcClient}
+	return &vmHandler, nil
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) {
+	cblogger.Info("Start")
+	handler := alirs.AlibabaVmSpecHandler{cloudConn.Region, cloudConn.VmSpecClient}
+	return &handler, nil
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateNLBHandler() (irs.NLBHandler, error) {
+	cblogger.Info("Start")
+	handler := alirs.AlibabaNLBHandler{cloudConn.Region, cloudConn.NLBClient, cloudConn.VMClient, cloudConn.VpcClient}
+	return &handler, nil
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateDiskHandler() (irs.DiskHandler, error) {
+	cblogger.Info("Start")
+	handler := alirs.AlibabaDiskHandler{cloudConn.Region, cloudConn.DiskClient}
+	return &handler, nil
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateMyImageHandler() (irs.MyImageHandler, error) {
+	cblogger.Info("Start")
+	handler := alirs.AlibabaMyImageHandler{cloudConn.Region, cloudConn.MyImageClient}
+	return &handler, nil
+
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateClusterHandler() (irs.ClusterHandler, error) {
+	cblogger.Info("Alibaba Cloud Driver: called CreateClusterHandler()!")
+
+	// temp
+	// getEnv & Setting
+	clusterHandler := alirs.AlibabaClusterHandler{RegionInfo: cloudConn.Region, CredentialInfo: cloudConn.CredentialInfo, VpcClient: cloudConn.Vpc2016Client, CsClient: cloudConn.Cs2015Client, EcsClient: cloudConn.Ecs2014Client}
+
+	return &clusterHandler, nil
+
+}
+
+func (AlibabaCloudConnection) IsConnected() (bool, error) {
+	return true, nil
+}
+
+func (AlibabaCloudConnection) Close() error {
+	return nil
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateAnyCallHandler() (irs.AnyCallHandler, error) {
+	return nil, errors.New("Alibaba Driver: not implemented")
+}
+
+func (cloudConn *AlibabaCloudConnection) CreatePriceInfoHandler() (irs.PriceInfoHandler, error) {
+	// priceInfoHandler := alirs.AlibabaPriceInfoHandler{Region: cloudConn.Region, Client: cloudConn.VMClient, BssClient: cloudConn.BssClient}
+	priceInfoHandler := alirs.AlibabaPriceInfoHandler{BssClient: cloudConn.BssClient, EcsClient: cloudConn.VmSpecClient}
+	return &priceInfoHandler, nil
+}
+
+func (cloudConn *AlibabaCloudConnection) CreateTagHandler() (irs.TagHandler, error) {
+	cblogger.Info("Start")
+	handler := alirs.AlibabaTagHandler{cloudConn.Region, cloudConn.VMClient, cloudConn.Cs2015Client, cloudConn.VpcClient, cloudConn.NLBClient, cloudConn.NasClient}
+	return &handler, nil
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/aws/connect/AwsCloudConnection.go b/cloud-control-manager/cloud-driver/drivers/aws/connect/AwsCloudConnection.go
index 5469836f..24cafdbb 100644
--- a/cloud-control-manager/cloud-driver/drivers/aws/connect/AwsCloudConnection.go
+++ b/cloud-control-manager/cloud-driver/drivers/aws/connect/AwsCloudConnection.go
@@ -11,6 +11,7 @@
 package connect
 
 import (
+	"errors"
 	cblog "github.com/cloud-barista/cb-log"
 	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
 
@@ -215,3 +216,7 @@ func (cloudConn *AwsCloudConnection) CreatePriceInfoHandler() (irs.PriceInfoHand
 	handler := ars.AwsPriceInfoHandler{Region: cloudConn.Region, Client: cloudConn.PriceInfoClient}
 	return &handler, nil
 }
+
+func (cloudConn *AwsCloudConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, errors.New("GCP Cloud Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/aws/connect/AwsCloudConnection.go.orig b/cloud-control-manager/cloud-driver/drivers/aws/connect/AwsCloudConnection.go.orig
new file mode 100644
index 00000000..5469836f
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/drivers/aws/connect/AwsCloudConnection.go.orig
@@ -0,0 +1,217 @@
+// Proof of Concepts of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// This is a Cloud Driver Example for PoC Test.
+//
+// by powerkim@etri.re.kr, 2019.06.
+
+package connect
+
+import (
+	cblog "github.com/cloud-barista/cb-log"
+	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
+
+	//irs2 "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/new-resources"
+	irs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+	"github.com/sirupsen/logrus"
+
+	ars "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/drivers/aws/resources"
+
+	//ec2drv "github.com/aws/aws-sdk-go/service/ec2"
+
+	"github.com/aws/aws-sdk-go/service/cloudwatch"
+	"github.com/aws/aws-sdk-go/service/costexplorer"
+	"github.com/aws/aws-sdk-go/service/ec2"
+	"github.com/aws/aws-sdk-go/service/efs"
+	"github.com/aws/aws-sdk-go/service/elbv2"
+	"github.com/aws/aws-sdk-go/service/pricing"
+
+	"github.com/aws/aws-sdk-go/service/autoscaling"
+	"github.com/aws/aws-sdk-go/service/eks"
+	"github.com/aws/aws-sdk-go/service/iam"
+)
+
+// type AwsCloudConnection struct{}
+type AwsCloudConnection struct {
+	CredentialInfo idrv.CredentialInfo
+	Region         idrv.RegionInfo
+	KeyPairClient  *ec2.EC2
+	VMClient       *ec2.EC2
+
+	VNetworkClient *ec2.EC2
+	//VNicClient     *ec2.EC2
+	ImageClient *ec2.EC2
+	//PublicIPClient *ec2.EC2
+	SecurityClient *ec2.EC2
+	VmSpecClient   *ec2.EC2
+
+	//NLBClient *elb.ELB
+	NLBClient *elbv2.ELBV2
+
+	//RegionZoneClient
+	RegionZoneClient *ec2.EC2
+
+	//PriceInfoClient
+	PriceInfoClient *pricing.Pricing
+
+	DiskClient    *ec2.EC2
+	MyImageClient *ec2.EC2
+
+	EKSClient         *eks.EKS
+	IamClient         *iam.IAM
+	AutoScalingClient *autoscaling.AutoScaling
+
+	AnyCallClient *ec2.EC2
+	TagClient     *ec2.EC2
+
+	CostExplorerClient *costexplorer.CostExplorer
+
+	CloudWatchClient *cloudwatch.CloudWatch
+	FileSystemClient *efs.EFS
+}
+
+var cblogger *logrus.Logger
+
+func init() {
+	// cblog is a global variable.
+	cblogger = cblog.GetLogger("CB-SPIDER")
+}
+
+func (cloudConn *AwsCloudConnection) IsConnected() (bool, error) {
+	return true, nil
+}
+
+func (cloudConn *AwsCloudConnection) Close() error {
+	return nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) {
+	tagHandler := cloudConn.CreateAwsTagHandler()
+	keyPairHandler := ars.AwsKeyPairHandler{CredentialInfo: cloudConn.CredentialInfo, Region: cloudConn.Region, Client: cloudConn.KeyPairClient, TagHandler: &tagHandler}
+	//keyPairHandler := ars.AwsKeyPairHandler{cloudConn.Region, cloudConn.KeyPairClient}
+
+	return &keyPairHandler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateVMHandler() (irs.VMHandler, error) {
+	tagHandler := cloudConn.CreateAwsTagHandler()
+	vmHandler := ars.AwsVMHandler{Region: cloudConn.Region, Client: cloudConn.VMClient, TagHandler: &tagHandler}
+	return &vmHandler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) {
+	tagHandler := cloudConn.CreateAwsTagHandler()
+	handler := ars.AwsVPCHandler{Region: cloudConn.Region, Client: cloudConn.VNetworkClient, TagHandler: &tagHandler}
+
+	return &handler, nil
+}
+
+// func (cloudConn *AwsCloudConnection) CreateImageHandler() (irs2.ImageHandler, error) {
+func (cloudConn *AwsCloudConnection) CreateImageHandler() (irs.ImageHandler, error) {
+	handler := ars.AwsImageHandler{Region: cloudConn.Region, Client: cloudConn.ImageClient}
+
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) {
+	tagHandler := cloudConn.CreateAwsTagHandler()
+	handler := ars.AwsSecurityHandler{Region: cloudConn.Region, Client: cloudConn.SecurityClient, TagHandler: &tagHandler}
+
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateTagHandler() (irs.TagHandler, error) {
+	handler := ars.AwsTagHandler{Region: cloudConn.Region, Client: cloudConn.VMClient, NLBClient: cloudConn.NLBClient, EKSClient: cloudConn.EKSClient, EFSClient: cloudConn.FileSystemClient}
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateAwsTagHandler() ars.AwsTagHandler {
+	handler := ars.AwsTagHandler{Region: cloudConn.Region, Client: cloudConn.VMClient, NLBClient: cloudConn.NLBClient, EKSClient: cloudConn.EKSClient, EFSClient: cloudConn.FileSystemClient}
+	return handler
+}
+
+/*
+func (cloudConn *AwsCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
+	cblogger.Info("Start")
+	handler := ars.AwsVNicHandler{cloudConn.Region, cloudConn.VNicClient}
+
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
+	cblogger.Info("Start")
+	handler := ars.AwsPublicIPHandler{cloudConn.Region, cloudConn.PublicIPClient}
+
+	return &handler, nil
+}
+*/
+
+func (cloudConn *AwsCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) {
+	handler := ars.AwsVmSpecHandler{Region: cloudConn.Region, Client: cloudConn.VmSpecClient}
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateNLBHandler() (irs.NLBHandler, error) {
+	tagHandler := cloudConn.CreateAwsTagHandler()
+	handler := ars.AwsNLBHandler{Region: cloudConn.Region, Client: cloudConn.NLBClient, VMClient: cloudConn.VMClient, TagHandler: &tagHandler}
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateDiskHandler() (irs.DiskHandler, error) {
+	tagHandler := cloudConn.CreateAwsTagHandler()
+	handler := ars.AwsDiskHandler{Region: cloudConn.Region, Client: cloudConn.DiskClient, TagHandler: &tagHandler}
+	return &handler, nil
+}
+
+// CreateFileSystemHandler implements connect.CloudConnection.
+func (cloudConn *AwsCloudConnection) CreateFileSystemHandler() (irs.FileSystemHandler, error) {
+	tagHandler := cloudConn.CreateAwsTagHandler()
+	handler := ars.AwsFileSystemHandler{Region: cloudConn.Region, Client: cloudConn.FileSystemClient, EC2Client: cloudConn.VNetworkClient, TagHandler: &tagHandler}
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateMyImageHandler() (irs.MyImageHandler, error) {
+	tagHandler := cloudConn.CreateAwsTagHandler()
+	handler := ars.AwsMyImageHandler{Region: cloudConn.Region, Client: cloudConn.MyImageClient, TagHandler: &tagHandler}
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateClusterHandler() (irs.ClusterHandler, error) {
+	tagHandler := cloudConn.CreateAwsTagHandler()
+	cblogger.Info("CreateClusterHandler through")
+	if cloudConn.MyImageClient == nil {
+		cblogger.Info("cloudConn.MyImageClient is nil")
+	}
+	if cloudConn.EKSClient == nil {
+		cblogger.Info("cloudConn.EKSClient is nil")
+	}
+	if cloudConn.VNetworkClient == nil {
+		cblogger.Info("cloudConn.VNetworkClient is nil")
+	}
+	if cloudConn.IamClient == nil {
+		cblogger.Info("cloudConn.IamClient is nil")
+	}
+	if cloudConn.AutoScalingClient == nil {
+		cblogger.Info("cloudConn.AutoScalingClient is nil")
+	}
+	handler := ars.AwsClusterHandler{Region: cloudConn.Region, Client: cloudConn.EKSClient, EC2Client: cloudConn.VNetworkClient, Iam: cloudConn.IamClient, AutoScaling: cloudConn.AutoScalingClient, TagHandler: &tagHandler}
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateAnyCallHandler() (irs.AnyCallHandler, error) {
+	handler := ars.AwsAnyCallHandler{Region: cloudConn.Region, CredentialInfo: cloudConn.CredentialInfo, Client: cloudConn.AnyCallClient, CeClient: cloudConn.CostExplorerClient, CwClient: cloudConn.CloudWatchClient}
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreateRegionZoneHandler() (irs.RegionZoneHandler, error) {
+	handler := ars.AwsRegionZoneHandler{Region: cloudConn.Region, Client: cloudConn.RegionZoneClient}
+	return &handler, nil
+}
+
+func (cloudConn *AwsCloudConnection) CreatePriceInfoHandler() (irs.PriceInfoHandler, error) {
+	handler := ars.AwsPriceInfoHandler{Region: cloudConn.Region, Client: cloudConn.PriceInfoClient}
+	return &handler, nil
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/azure/connect/Azure_CloudConnection.go b/cloud-control-manager/cloud-driver/drivers/azure/connect/Azure_CloudConnection.go
index 075e67e5..08b99a91 100644
--- a/cloud-control-manager/cloud-driver/drivers/azure/connect/Azure_CloudConnection.go
+++ b/cloud-control-manager/cloud-driver/drivers/azure/connect/Azure_CloudConnection.go
@@ -269,3 +269,21 @@ func (cloudConn *AzureCloudConnection) CreateTagHandler() (irs.TagHandler, error
 	return &tagHandler, nil
 	// return nil, errors.New("Azure Driver: not implemented")
 }
+
+func (cloudConn *AzureCloudConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	cblogger.Info("Azure Cloud Driver: called CreateMonitoringHandler()!")
+	monitoringHandler := azrs.AzureMonitoringHandler{
+		CredentialInfo:                  cloudConn.CredentialInfo,
+		Region:                          cloudConn.Region,
+		Ctx:                             cloudConn.Ctx,
+		VMClient:                        cloudConn.VMClient,
+		ManagedClustersClient:           cloudConn.ManagedClustersClient,
+		SecurityGroupsClient:            cloudConn.SecurityGroupClient,
+		VirtualNetworksClient:           cloudConn.VNetClient,
+		AgentPoolsClient:                cloudConn.AgentPoolsClient,
+		VirtualMachineScaleSetsClient:   cloudConn.VirtualMachineScaleSetsClient,
+		VirtualMachineScaleSetVMsClient: cloudConn.VirtualMachineScaleSetVMsClient,
+		MetricClient:                    cloudConn.MetricClient,
+	}
+	return &monitoringHandler, nil
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/azure/main/Test_Resources.go b/cloud-control-manager/cloud-driver/drivers/azure/main/Test_Resources.go
index 2c7b5668..23dbfec5 100644
--- a/cloud-control-manager/cloud-driver/drivers/azure/main/Test_Resources.go
+++ b/cloud-control-manager/cloud-driver/drivers/azure/main/Test_Resources.go
@@ -2278,6 +2278,219 @@ Loop:
 	}
 }
 
+func testMonitoringHandlerListPrint() {
+	cblogger.Info("Test MonitoringHandler")
+	cblogger.Info("0. Print Menu")
+	cblogger.Info("1. GetVMMetricData()")
+	cblogger.Info("2. GetClusterNodeMetricData()")
+	cblogger.Info("3. Exit")
+}
+
+func testMonitoringHandlerMetricTypeListPrint() {
+	cblogger.Info("Metric Types")
+	cblogger.Info("1. CPUUsage")
+	cblogger.Info("2. MemoryUsage")
+	cblogger.Info("3. DiskRead")
+	cblogger.Info("4. DiskWrite")
+	cblogger.Info("5. DiskReadOps")
+	cblogger.Info("6. DiskWriteOps")
+	cblogger.Info("7. NetworkIn")
+	cblogger.Info("8. NetworkOut")
+}
+
+func testMonitoringHandler(config Config) {
+	resourceHandler, err := getResourceHandler("monitoring", config)
+	if err != nil {
+		cblogger.Error(err)
+		return
+	}
+	monitoringHandler := resourceHandler.(irs.MonitoringHandler)
+
+	testMonitoringHandlerListPrint()
+Loop:
+	for {
+		var commandNum int
+		inputCnt, err := fmt.Scan(&commandNum)
+		if err != nil {
+			cblogger.Error(err)
+		}
+
+		if inputCnt == 1 {
+			switch commandNum {
+			case 0:
+				testMonitoringHandlerListPrint()
+			case 1:
+				cblogger.Info("Start GetMetricData() ...")
+
+				fmt.Println("=== Enter VM's name ===")
+				in := bufio.NewReader(os.Stdin)
+				vmName, err := in.ReadString('\n')
+				if err != nil {
+					cblogger.Error(err)
+				}
+				vmName = strings.TrimSpace(vmName)
+
+				fmt.Println("=== Enter metric type (Default: cpu_usage) ===")
+				testMonitoringHandlerMetricTypeListPrint()
+				inputCnt, err := fmt.Scan(&commandNum)
+				if err != nil {
+					cblogger.Error(err)
+				}
+				var metricType irs.MetricType
+				if inputCnt == 1 {
+					switch commandNum {
+					case 1:
+						metricType = irs.CPUUsage
+					case 2:
+						metricType = irs.MemoryUsage
+					case 3:
+						metricType = irs.DiskRead
+					case 4:
+						metricType = irs.DiskWrite
+					case 5:
+						metricType = irs.DiskReadOps
+					case 6:
+						metricType = irs.DiskWriteOps
+					case 7:
+						metricType = irs.NetworkIn
+					case 8:
+						metricType = irs.NetworkOut
+					default:
+						cblogger.Error("Invalid input")
+					}
+				}
+
+				fmt.Println("=== Enter period (minute) (Default: 1m) ===")
+				in = bufio.NewReader(os.Stdin)
+				periodMinute, err := in.ReadString('\n')
+				if err != nil {
+					cblogger.Error(err)
+				}
+				periodMinute = strings.TrimSpace(periodMinute)
+
+				fmt.Println("=== Enter time before (hour) (Default: 1h) ===")
+				in = bufio.NewReader(os.Stdin)
+				timeBeforeHour, err := in.ReadString('\n')
+				if err != nil {
+					cblogger.Error(err)
+				}
+				timeBeforeHour = strings.TrimSpace(timeBeforeHour)
+
+				if getVMMetricData, err := monitoringHandler.GetVMMetricData(
+					irs.VMMonitoringReqInfo{
+						VMIID: irs.IID{
+							NameId: vmName,
+						},
+						MetricType:     metricType,
+						IntervalMinute: periodMinute,
+						TimeBeforeHour: timeBeforeHour,
+					}); err != nil {
+					cblogger.Error(err)
+				} else {
+					spew.Dump(getVMMetricData)
+				}
+				cblogger.Info("Finish GetVMMetricData()")
+			case 2:
+				cblogger.Info("Start GetClusterNodeMetricData() ...")
+
+				fmt.Println("=== Enter Cluster's name ===")
+				in := bufio.NewReader(os.Stdin)
+				clusterName, err := in.ReadString('\n')
+				if err != nil {
+					cblogger.Error(err)
+				}
+				clusterName = strings.TrimSpace(clusterName)
+
+				fmt.Println("=== Enter NodeGroup's name ===")
+				in = bufio.NewReader(os.Stdin)
+				nodeGroupName, err := in.ReadString('\n')
+				if err != nil {
+					cblogger.Error(err)
+				}
+				nodeGroupName = strings.TrimSpace(nodeGroupName)
+
+				fmt.Println("=== Enter VM's name ===")
+				in = bufio.NewReader(os.Stdin)
+				vmName, err := in.ReadString('\n')
+				if err != nil {
+					cblogger.Error(err)
+				}
+				vmName = strings.TrimSpace(vmName)
+
+				fmt.Println("=== Enter metric type (Default: cpu_usage) ===")
+				testMonitoringHandlerMetricTypeListPrint()
+				inputCnt, err := fmt.Scan(&commandNum)
+				if err != nil {
+					cblogger.Error(err)
+				}
+				var metricType irs.MetricType
+				if inputCnt == 1 {
+					switch commandNum {
+					case 1:
+						metricType = irs.CPUUsage
+					case 2:
+						metricType = irs.MemoryUsage
+					case 3:
+						metricType = irs.DiskRead
+					case 4:
+						metricType = irs.DiskWrite
+					case 5:
+						metricType = irs.DiskReadOps
+					case 6:
+						metricType = irs.DiskWriteOps
+					case 7:
+						metricType = irs.NetworkIn
+					case 8:
+						metricType = irs.NetworkOut
+					default:
+						cblogger.Error("Invalid input")
+					}
+				}
+
+				fmt.Println("=== Enter period (minute) (Default: 1m) ===")
+				in = bufio.NewReader(os.Stdin)
+				periodMinute, err := in.ReadString('\n')
+				if err != nil {
+					cblogger.Error(err)
+				}
+				periodMinute = strings.TrimSpace(periodMinute)
+
+				fmt.Println("=== Enter time before (hour) (Default: 1h) ===")
+				in = bufio.NewReader(os.Stdin)
+				timeBeforeHour, err := in.ReadString('\n')
+				if err != nil {
+					cblogger.Error(err)
+				}
+				timeBeforeHour = strings.TrimSpace(timeBeforeHour)
+
+				if getVMMetricData, err := monitoringHandler.GetClusterNodeMetricData(
+					irs.ClusterNodeMonitoringReqInfo{
+						ClusterIID: irs.IID{
+							NameId: clusterName,
+						},
+						NodeGroupID: irs.IID{
+							NameId: nodeGroupName,
+						},
+						NodeIID: irs.IID{
+							NameId: vmName,
+						},
+						MetricType:     metricType,
+						IntervalMinute: periodMinute,
+						TimeBeforeHour: timeBeforeHour,
+					}); err != nil {
+					cblogger.Error(err)
+				} else {
+					spew.Dump(getVMMetricData)
+				}
+				cblogger.Info("Finish GetVMMetricData()")
+			case 3:
+				cblogger.Info("Exit")
+				break Loop
+			}
+		}
+	}
+}
+
 func main() {
 	showTestHandlerInfo()
 	config := readConfigFile()
diff --git a/cloud-control-manager/cloud-driver/drivers/azure/resources/MonitoringHandler.go b/cloud-control-manager/cloud-driver/drivers/azure/resources/MonitoringHandler.go
new file mode 100644
index 00000000..4cda7b34
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/drivers/azure/resources/MonitoringHandler.go
@@ -0,0 +1,332 @@
+// Proof of Concepts of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// Azure Monitoring PoC by ish@innogrid.com, 2024.08.
+
+package resources
+
+import (
+	"context"
+	"errors"
+	"fmt"
+	"github.com/Azure/azure-sdk-for-go/sdk/monitor/azquery"
+	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/compute/armcompute/v6"
+	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/containerservice/armcontainerservice/v6"
+	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/network/armnetwork/v6"
+	"strconv"
+	"strings"
+	"time"
+
+	call "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/call-log"
+
+	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
+	irs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+)
+
+type AzureMonitoringHandler struct {
+	CredentialInfo                  idrv.CredentialInfo
+	Region                          idrv.RegionInfo
+	Ctx                             context.Context
+	VMClient                        *armcompute.VirtualMachinesClient
+	ManagedClustersClient           *armcontainerservice.ManagedClustersClient
+	SecurityGroupsClient            *armnetwork.SecurityGroupsClient
+	VirtualNetworksClient           *armnetwork.VirtualNetworksClient
+	AgentPoolsClient                *armcontainerservice.AgentPoolsClient
+	VirtualMachineScaleSetsClient   *armcompute.VirtualMachineScaleSetsClient
+	VirtualMachineScaleSetVMsClient *armcompute.VirtualMachineScaleSetVMsClient
+	MetricClient                    *azquery.MetricsClient
+}
+
+var availableIntervalMinutes = []string{
+	"1",
+	"5",
+	"15",
+	"30",
+	"60",
+	"360",
+	"720",
+	"1440",
+}
+
+func toAzureIntervalMinute(intervalMinute string) (string, error) {
+	switch intervalMinute {
+	case availableIntervalMinutes[0]:
+		return "PT1M", nil
+	case availableIntervalMinutes[1]:
+		return "PT5M", nil
+	case availableIntervalMinutes[2]:
+		return "PT15M", nil
+	case availableIntervalMinutes[3]:
+		return "PT30M", nil
+	case availableIntervalMinutes[4]:
+		return "PT1H", nil
+	case availableIntervalMinutes[5]:
+		return "PT6H", nil
+	case availableIntervalMinutes[6]:
+		return "PT12H", nil
+	case availableIntervalMinutes[7]:
+		return "P1D", nil
+	default:
+		return "", errors.New(fmt.Sprintf("Unsupported interval minute: %s. "+
+			"Available interval miniutes: %s", intervalMinute, strings.Join(availableIntervalMinutes, ",")))
+	}
+}
+
+func (monitoringHandler *AzureMonitoringHandler) getMetricData(metricType irs.MetricType, interval string, timeBeforeHour int, resourceID string) (irs.MetricData, error) {
+	endTime := time.Now().UTC()
+	startTime := endTime.Add(time.Duration(-timeBeforeHour) * time.Hour)
+	timespan := azquery.TimeInterval(fmt.Sprintf("%s/%s", startTime.Format(time.RFC3339), endTime.Format(time.RFC3339)))
+
+	var metricName = "Percentage CPU" // irs.CPUUsage
+	var aggregation = azquery.AggregationTypeAverage
+
+	switch metricType {
+	case irs.MemoryUsage:
+		metricName = "Available Memory Bytes"
+	case irs.DiskRead:
+		metricName = "Disk Read Bytes"
+		aggregation = azquery.AggregationTypeTotal
+	case irs.DiskWrite:
+		metricName = "Disk Write Bytes"
+		aggregation = azquery.AggregationTypeTotal
+	case irs.DiskReadOps:
+		metricName = "Disk Read Operations/Sec"
+	case irs.DiskWriteOps:
+		metricName = "Disk Write Operations/Sec"
+	case irs.NetworkIn:
+		metricName = "Network In"
+		aggregation = azquery.AggregationTypeTotal
+	case irs.NetworkOut:
+		metricName = "Network Out"
+		aggregation = azquery.AggregationTypeTotal
+	}
+
+	metrics := make([]string, 0)
+	metrics = append(metrics, metricName)
+	metricNames := strings.Join(metrics, ",")
+	resultType := azquery.ResultTypeData
+
+	resp, err := monitoringHandler.MetricClient.QueryResource(context.Background(), resourceID, &azquery.MetricsClientQueryResourceOptions{
+		Aggregation:     []*azquery.AggregationType{&aggregation},
+		Filter:          nil,
+		Interval:        toStrPtr(interval),
+		MetricNames:     &metricNames,
+		MetricNamespace: nil,
+		OrderBy:         nil,
+		ResultType:      &resultType,
+		Timespan:        &timespan,
+		Top:             nil,
+	})
+	if err != nil {
+		getErr := errors.New(fmt.Sprintf("Failed to get metric data. err = %s", err))
+		cblogger.Error(getErr.Error())
+		return irs.MetricData{}, getErr
+	}
+
+	var vmMonitoringInfo irs.MetricData
+	var timestampValues []irs.TimestampValue
+
+	for i, metric := range resp.Value {
+		if i == 0 && metric.Unit != nil {
+			if metric.Name != nil && metric.Name.Value != nil {
+				vmMonitoringInfo.MetricName = *metric.Name.Value
+			}
+			vmMonitoringInfo.MetricUnit = string(*metric.Unit)
+		}
+
+		for _, timeseries := range metric.TimeSeries {
+			if timeseries.Data == nil {
+				continue
+			}
+			for _, data := range timeseries.Data {
+				timestamp := data.TimeStamp
+				if timestamp == nil {
+					continue
+				}
+
+				var value *float64
+				if aggregation == azquery.AggregationTypeTotal {
+					value = data.Total
+				} else {
+					value = data.Average
+				}
+
+				if value == nil {
+					continue
+				}
+
+				timestampValues = append(timestampValues, irs.TimestampValue{
+					Timestamp: *timestamp,
+					Value:     strconv.FormatFloat(*value, 'f', -1, 64),
+				})
+			}
+		}
+	}
+
+	vmMonitoringInfo.TimestampValues = timestampValues
+
+	return vmMonitoringInfo, nil
+}
+
+func (monitoringHandler *AzureMonitoringHandler) GetVMMetricData(vmMonitoringReqInfo irs.VMMonitoringReqInfo) (irs.MetricData, error) {
+	intervalMinute, err := strconv.Atoi(vmMonitoringReqInfo.IntervalMinute)
+	if err != nil {
+		if vmMonitoringReqInfo.IntervalMinute == "" {
+			vmMonitoringReqInfo.IntervalMinute = "1"
+			intervalMinute = 1
+		} else {
+			return irs.MetricData{}, errors.New("invalid value of IntervalMinute")
+		}
+	}
+
+	interval, err := toAzureIntervalMinute(vmMonitoringReqInfo.IntervalMinute)
+	if err != nil {
+		return irs.MetricData{}, err
+	}
+
+	timeBeforeHour, err := strconv.Atoi(vmMonitoringReqInfo.TimeBeforeHour)
+	if err != nil {
+		if vmMonitoringReqInfo.TimeBeforeHour == "" {
+			vmMonitoringReqInfo.TimeBeforeHour = "1"
+			timeBeforeHour = 1
+		} else {
+			return irs.MetricData{}, errors.New("invalid value of TimeBeforeHour")
+		}
+	}
+	if timeBeforeHour < 0 {
+		return irs.MetricData{}, errors.New("invalid value of TimeBeforeHour")
+	}
+
+	if timeBeforeHour*60 < intervalMinute {
+		return irs.MetricData{}, errors.New("IntervalMinute is too far in the past")
+	}
+
+	// log HisCall
+	hiscallInfo := GetCallLogScheme(monitoringHandler.Region, call.MONITORING, vmMonitoringReqInfo.VMIID.NameId, "GetVMMetricData()")
+	start := call.Start()
+
+	convertedIID, err := ConvertVMIID(vmMonitoringReqInfo.VMIID, monitoringHandler.CredentialInfo, monitoringHandler.Region)
+	if err != nil {
+		getErr := errors.New(fmt.Sprintf("Failed to get metric data. err = %s", err))
+		cblogger.Error(getErr.Error())
+		LoggingError(hiscallInfo, getErr)
+		return irs.MetricData{}, getErr
+	}
+
+	vm, err := GetRawVM(convertedIID, monitoringHandler.Region.Region, monitoringHandler.VMClient, monitoringHandler.Ctx)
+	if err != nil {
+		getErr := errors.New(fmt.Sprintf("Failed to get metric data. err = %s", err))
+		cblogger.Error(getErr.Error())
+		LoggingError(hiscallInfo, getErr)
+		return irs.MetricData{}, getErr
+	}
+
+	vmMonitoringInfo, err := monitoringHandler.getMetricData(vmMonitoringReqInfo.MetricType, interval, timeBeforeHour, *vm.ID)
+	if err != nil {
+		getErr := errors.New(fmt.Sprintf("Failed to get metric data. err = %s", err))
+		cblogger.Error(getErr.Error())
+		LoggingError(hiscallInfo, getErr)
+		return irs.MetricData{}, getErr
+	}
+
+	LoggingInfo(hiscallInfo, start)
+
+	return vmMonitoringInfo, nil
+}
+
+func (monitoringHandler *AzureMonitoringHandler) GetClusterNodeMetricData(clusterNodeMonitoringReqInfo irs.ClusterNodeMonitoringReqInfo) (irs.MetricData, error) {
+	intervalMinute, err := strconv.Atoi(clusterNodeMonitoringReqInfo.IntervalMinute)
+	if err != nil {
+		if clusterNodeMonitoringReqInfo.IntervalMinute == "" {
+			clusterNodeMonitoringReqInfo.IntervalMinute = "1"
+			intervalMinute = 1
+		} else {
+			return irs.MetricData{}, errors.New("invalid value of IntervalMinute")
+		}
+	}
+
+	interval, err := toAzureIntervalMinute(clusterNodeMonitoringReqInfo.IntervalMinute)
+	if err != nil {
+		return irs.MetricData{}, err
+	}
+
+	timeBeforeHour, err := strconv.Atoi(clusterNodeMonitoringReqInfo.TimeBeforeHour)
+	if err != nil {
+		if clusterNodeMonitoringReqInfo.TimeBeforeHour == "" {
+			clusterNodeMonitoringReqInfo.TimeBeforeHour = "1"
+			timeBeforeHour = 1
+		} else {
+			return irs.MetricData{}, errors.New("invalid value of TimeBeforeHour")
+		}
+	}
+	if timeBeforeHour < 0 {
+		return irs.MetricData{}, errors.New("invalid value of TimeBeforeHour")
+	}
+
+	if timeBeforeHour*60 < intervalMinute {
+		return irs.MetricData{}, errors.New("IntervalMinute is too far in the past")
+	}
+
+	// log HisCall
+	hiscallInfo := GetCallLogScheme(monitoringHandler.Region, call.MONITORING, clusterNodeMonitoringReqInfo.ClusterIID.NameId, "GetClusterNodeMetricData()")
+	start := call.Start()
+
+	clusterHandler := AzureClusterHandler{
+		Region:                          monitoringHandler.Region,
+		CredentialInfo:                  monitoringHandler.CredentialInfo,
+		Ctx:                             monitoringHandler.Ctx,
+		ManagedClustersClient:           monitoringHandler.ManagedClustersClient,
+		SecurityGroupsClient:            monitoringHandler.SecurityGroupsClient,
+		VirtualNetworksClient:           monitoringHandler.VirtualNetworksClient,
+		AgentPoolsClient:                monitoringHandler.AgentPoolsClient,
+		VirtualMachineScaleSetsClient:   monitoringHandler.VirtualMachineScaleSetsClient,
+		VirtualMachineScaleSetVMsClient: monitoringHandler.VirtualMachineScaleSetVMsClient,
+	}
+
+	cluster, err := clusterHandler.GetCluster(clusterNodeMonitoringReqInfo.ClusterIID)
+	if err != nil {
+		getErr := errors.New(fmt.Sprintf("Failed to get cluster info. err = %s", err))
+		cblogger.Error(getErr.Error())
+		LoggingError(hiscallInfo, getErr)
+		return irs.MetricData{}, getErr
+	}
+
+	var nodeFound bool
+	var resourceID string
+
+	for _, nodeGroup := range cluster.NodeGroupList {
+		if nodeGroup.IId.NameId == clusterNodeMonitoringReqInfo.NodeGroupID.NameId ||
+			nodeGroup.IId.SystemId == clusterNodeMonitoringReqInfo.NodeGroupID.SystemId {
+			for _, node := range nodeGroup.Nodes {
+				if node.NameId == clusterNodeMonitoringReqInfo.NodeIID.NameId ||
+					node.SystemId == clusterNodeMonitoringReqInfo.NodeIID.SystemId {
+					nodeFound = true
+					resourceID = node.SystemId
+					break
+				}
+			}
+		}
+	}
+
+	if !nodeFound {
+		getErr := errors.New(fmt.Sprintf("Failed to get metric data. err = Node not found from the cluster"))
+		cblogger.Error(getErr.Error())
+		LoggingError(hiscallInfo, getErr)
+		return irs.MetricData{}, getErr
+	}
+
+	vmMonitoringInfo, err := monitoringHandler.getMetricData(clusterNodeMonitoringReqInfo.MetricType, interval, timeBeforeHour, resourceID)
+	if err != nil {
+		getErr := errors.New(fmt.Sprintf("Failed to get metric data. err = %s", err))
+		cblogger.Error(getErr.Error())
+		LoggingError(hiscallInfo, getErr)
+		return irs.MetricData{}, getErr
+	}
+
+	LoggingInfo(hiscallInfo, start)
+
+	return vmMonitoringInfo, nil
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/gcp/connect/GCP_CloudConnection.go b/cloud-control-manager/cloud-driver/drivers/gcp/connect/GCP_CloudConnection.go
index a2b48357..9deab67e 100644
--- a/cloud-control-manager/cloud-driver/drivers/gcp/connect/GCP_CloudConnection.go
+++ b/cloud-control-manager/cloud-driver/drivers/gcp/connect/GCP_CloudConnection.go
@@ -12,6 +12,7 @@ package connect
 
 import (
 	"context"
+	"errors"
 
 	filestore "cloud.google.com/go/filestore/apiv1"
 	cblog "github.com/cloud-barista/cb-log"
@@ -191,3 +192,7 @@ func (cloudConn *GCPCloudConnection) CreateTagHandler() (irs.TagHandler, error)
 
 	return &tagHandler, nil
 }
+
+func (cloudConn *GCPCloudConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, errors.New("GCP Cloud Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/gcp/connect/GCP_CloudConnection.go.orig b/cloud-control-manager/cloud-driver/drivers/gcp/connect/GCP_CloudConnection.go.orig
new file mode 100644
index 00000000..a2b48357
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/drivers/gcp/connect/GCP_CloudConnection.go.orig
@@ -0,0 +1,193 @@
+// Proof of Concepts of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// This is a Cloud Driver Example for PoC Test.
+//
+// by jaz, 2019.07.
+
+package connect
+
+import (
+	"context"
+
+	filestore "cloud.google.com/go/filestore/apiv1"
+	cblog "github.com/cloud-barista/cb-log"
+	gcprs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/drivers/gcp/resources"
+	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
+	irs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+	"github.com/sirupsen/logrus"
+	"google.golang.org/api/cloudbilling/v1"
+	cbb "google.golang.org/api/cloudbilling/v1beta"
+	compute "google.golang.org/api/compute/v1"
+	"google.golang.org/api/container/v1"
+)
+
+var cblogger *logrus.Logger
+
+func init() {
+	// cblog is a global variable.
+	cblogger = cblog.GetLogger("CB-SPIDER")
+}
+
+// @Infomation
+// BillingCatalogClient ì™€ CostEstimationClient ë¶„ë¦¬
+// í˜„ìž¬(2024-01-02) ì œê³µë˜ëŠ” BillingCatalogClient sdk ì™€ CostEstimationClient sdk ì˜ ë²„ì „ ì°¨ì´ë¡œ ì¸í•´ ë‘ í´ë¼ì´ì–¸íŠ¸ ë¶„ë¦¬
+// ì¶”í›„ api í†µí•© ì‹œ ì½”ë“œ í†µí•© ìž‘ì—… í•„ìš”
+
+type GCPCloudConnection struct {
+	Region               idrv.RegionInfo
+	Credential           idrv.CredentialInfo
+	Ctx                  context.Context
+	VMClient             *compute.Service
+	ImageClient          *compute.Service
+	PublicIPClient       *compute.Service
+	SecurityGroupClient  *compute.Service
+	VNetClient           *compute.Service
+	VNicClient           *compute.Service
+	SubnetClient         *compute.Service
+	VMSpecClient         *compute.Service
+	VPCClient            *compute.Service
+	RegionZoneClient     *compute.Service
+	ContainerClient      *container.Service
+	BillingCatalogClient *cloudbilling.APIService
+	CostEstimationClient *cbb.Service
+	FilestoreClient      *filestore.CloudFilestoreManagerClient
+}
+
+// CreateFileSystemHandler implements connect.CloudConnection.
+func (cloudConn *GCPCloudConnection) CreateFileSystemHandler() (irs.FileSystemHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateFileSystemHandler()!")
+	fsHandler := gcprs.GCPFileSystemHandler{Region: cloudConn.Region, Ctx: cloudConn.Ctx, Client: cloudConn.VMClient, ContainerClient: cloudConn.ContainerClient, Credential: cloudConn.Credential, FilestoreClient: cloudConn.FilestoreClient}
+	return &fsHandler, nil
+}
+
+// func (cloudConn *GCPCloudConnection) CreateVNetworkHandler() (irs.VNetworkHandler, error) {
+// 	cblogger.Info("GCP Cloud Driver: called CreateVNetworkHandler()!")
+
+// 	vNetHandler := gcprs.GCPVNetworkHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VNetClient, cloudConn.Credential}
+// 	return &vNetHandler, nil
+// }
+
+func (cloudConn *GCPCloudConnection) CreateImageHandler() (irs.ImageHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateImageHandler()!")
+	imageHandler := gcprs.GCPImageHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.ImageClient, cloudConn.Credential}
+	return &imageHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateSecurityHandler()!")
+	sgHandler := gcprs.GCPSecurityHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.SecurityGroupClient, cloudConn.Credential}
+	return &sgHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateKeyPairHandler()!")
+	keypairHandler := gcprs.GCPKeyPairHandler{cloudConn.Credential, cloudConn.Region}
+	return &keypairHandler, nil
+}
+
+// func (cloudConn *GCPCloudConnection) CreateVNicHandler() (irs.VNicHandler, error) {
+// 	cblogger.Info("GCP Cloud Driver: called CreateVNicHandler()!")
+// 	vNicHandler := gcprs.GCPVNicHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VNicClient, cloudConn.Credential}
+// 	return &vNicHandler, nil
+// }
+
+// func (cloudConn *GCPCloudConnection) CreatePublicIPHandler() (irs.PublicIPHandler, error) {
+// 	cblogger.Info("GCP Cloud Driver: called CreatePublicIPHandler()!")
+// 	publicIPHandler := gcprs.GCPPublicIPHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.PublicIPClient, cloudConn.Credential}
+// 	return &publicIPHandler, nil
+// }
+
+func (cloudConn *GCPCloudConnection) CreateVMHandler() (irs.VMHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateVMHandler()!")
+	vmHandler := gcprs.GCPVMHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VMClient, cloudConn.Credential}
+	return &vmHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateVPCHandler()!")
+	vpcHandler := gcprs.GCPVPCHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VMClient, cloudConn.Credential}
+	return &vpcHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateVMSpecHandler()!")
+	vmSpecHandler := gcprs.GCPVMSpecHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VMClient, cloudConn.Credential}
+	return &vmSpecHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateNLBHandler() (irs.NLBHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateLoadBalancerHandler()!")
+	nlbHandler := gcprs.GCPNLBHandler{Region: cloudConn.Region, Ctx: cloudConn.Ctx, Client: cloudConn.VMClient, Credential: cloudConn.Credential}
+	return &nlbHandler, nil
+}
+
+func (GCPCloudConnection) IsConnected() (bool, error) {
+	return true, nil
+}
+func (GCPCloudConnection) Close() error {
+	return nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateDiskHandler() (irs.DiskHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateDiskHandler()!")
+	diskHandler := gcprs.GCPDiskHandler{Region: cloudConn.Region, Ctx: cloudConn.Ctx, Client: cloudConn.VMClient, Credential: cloudConn.Credential}
+	return &diskHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateMyImageHandler() (irs.MyImageHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateMyImageHandler()!")
+	myImageHandler := gcprs.GCPMyImageHandler{Region: cloudConn.Region, Ctx: cloudConn.Ctx, Client: cloudConn.VMClient, Credential: cloudConn.Credential}
+	return &myImageHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateClusterHandler() (irs.ClusterHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateClusterHandler()!")
+	clusterHandler := gcprs.GCPClusterHandler{Region: cloudConn.Region, Ctx: cloudConn.Ctx, Client: cloudConn.VMClient, ContainerClient: cloudConn.ContainerClient, Credential: cloudConn.Credential}
+	return &clusterHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateAnyCallHandler() (irs.AnyCallHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateAnyCallHandler()!")
+	anyCallHandler := gcprs.GCPAnyCallHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.VMClient, cloudConn.Credential}
+	return &anyCallHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateRegionZoneHandler() (irs.RegionZoneHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateRegionZoneHandler()!")
+	regionZoneHandler := gcprs.GCPRegionZoneHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.RegionZoneClient, cloudConn.Credential}
+	return &regionZoneHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreatePriceInfoHandler() (irs.PriceInfoHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateRegionZoneHandler()!")
+
+	//priceInfoHandler := gcprs.GCPPriceInfoHandler{cloudConn.Region, cloudConn.Ctx, cloudConn.CloudBillingClient, cloudConn.Credential}
+	priceInfoHandler := gcprs.GCPPriceInfoHandler{
+		Region:               cloudConn.Region,
+		Ctx:                  cloudConn.Ctx,
+		Client:               cloudConn.VMClient,
+		BillingCatalogClient: cloudConn.BillingCatalogClient,
+		CostEstimationClient: cloudConn.CostEstimationClient,
+		Credential:           cloudConn.Credential,
+	}
+
+	return &priceInfoHandler, nil
+}
+
+func (cloudConn *GCPCloudConnection) CreateTagHandler() (irs.TagHandler, error) {
+	cblogger.Info("GCP Cloud Driver: called CreateTagHandler()!")
+
+	tagHandler := gcprs.GCPTagHandler{
+		Region:          cloudConn.Region,
+		Ctx:             cloudConn.Ctx,
+		Credential:      cloudConn.Credential,
+		ComputeClient:   cloudConn.VMClient,
+		ContainerClient: cloudConn.ContainerClient,
+	}
+
+	return &tagHandler, nil
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/ibm/connect/Ibm_CloudConnection.go b/cloud-control-manager/cloud-driver/drivers/ibm/connect/Ibm_CloudConnection.go
index a137d428..8b5d887d 100644
--- a/cloud-control-manager/cloud-driver/drivers/ibm/connect/Ibm_CloudConnection.go
+++ b/cloud-control-manager/cloud-driver/drivers/ibm/connect/Ibm_CloudConnection.go
@@ -217,3 +217,7 @@ func (cloudConn *IbmCloudConnection) CreateTagHandler() (irs.TagHandler, error)
 	}
 	return &TagHandler, nil
 }
+
+func (cloudConn *IbmCloudConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, errors.New("Ibm Cloud Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/ibm/connect/Ibm_CloudConnection.go.orig b/cloud-control-manager/cloud-driver/drivers/ibm/connect/Ibm_CloudConnection.go.orig
new file mode 100644
index 00000000..a137d428
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/drivers/ibm/connect/Ibm_CloudConnection.go.orig
@@ -0,0 +1,219 @@
+package connect
+
+import (
+	"context"
+	"errors"
+
+	"github.com/IBM/platform-services-go-sdk/globalsearchv2"
+
+	"github.com/IBM/platform-services-go-sdk/globaltaggingv1"
+	"github.com/IBM/vpc-go-sdk/vpcv1"
+	cblog "github.com/cloud-barista/cb-log"
+	ibmrs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/drivers/ibm/resources"
+	"github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/drivers/ibm/utils/kubernetesserviceapiv1"
+	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
+	irs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+	"github.com/sirupsen/logrus"
+)
+
+var cblogger *logrus.Logger
+
+func init() {
+	// cblog is a global variable.
+	cblogger = cblog.GetLogger("CB-SPIDER")
+}
+
+type IbmCloudConnection struct {
+	CredentialInfo idrv.CredentialInfo
+	Region         idrv.RegionInfo
+	VpcService     *vpcv1.VpcV1
+	ClusterService *kubernetesserviceapiv1.KubernetesServiceApiV1
+	TaggingService *globaltaggingv1.GlobalTaggingV1
+	SearchService  *globalsearchv2.GlobalSearchV2
+	Ctx            context.Context
+}
+
+func (cloudConn *IbmCloudConnection) CreateImageHandler() (irs.ImageHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateImageHandler()!")
+	imageHandler := ibmrs.IbmImageHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		VpcService:     cloudConn.VpcService,
+		Ctx:            cloudConn.Ctx,
+	}
+	return &imageHandler, nil
+}
+
+func (cloudConn *IbmCloudConnection) CreateVMHandler() (irs.VMHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateVMHandler()!")
+	vmHandler := ibmrs.IbmVMHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		VpcService:     cloudConn.VpcService,
+		Ctx:            cloudConn.Ctx,
+		TaggingService: cloudConn.TaggingService,
+		SearchService:  cloudConn.SearchService,
+	}
+	return &vmHandler, nil
+}
+
+func (cloudConn *IbmCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateVPCHandler()!")
+	vpcHandler := ibmrs.IbmVPCHandler{
+		Region:         cloudConn.Region,
+		CredentialInfo: cloudConn.CredentialInfo,
+		VpcService:     cloudConn.VpcService,
+		Ctx:            cloudConn.Ctx,
+		TaggingService: cloudConn.TaggingService,
+		SearchService:  cloudConn.SearchService,
+	}
+	return &vpcHandler, nil
+}
+func (cloudConn *IbmCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateSecurityHandler()!")
+	securityHandler := ibmrs.IbmSecurityHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		VpcService:     cloudConn.VpcService,
+		Ctx:            cloudConn.Ctx,
+		TaggingService: cloudConn.TaggingService,
+		SearchService:  cloudConn.SearchService,
+	}
+	return &securityHandler, nil
+}
+func (cloudConn *IbmCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateVPCHandler()!")
+	keyPairHandler := ibmrs.IbmKeyPairHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		VpcService:     cloudConn.VpcService,
+		Ctx:            cloudConn.Ctx,
+		TaggingService: cloudConn.TaggingService,
+		SearchService:  cloudConn.SearchService,
+	}
+	return &keyPairHandler, nil
+}
+func (cloudConn *IbmCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateVMSpecHandler()!")
+	vmSpecHandler := ibmrs.IbmVmSpecHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		VpcService:     cloudConn.VpcService,
+		Ctx:            cloudConn.Ctx,
+	}
+	return &vmSpecHandler, nil
+}
+
+func (cloudConn *IbmCloudConnection) CreateNLBHandler() (irs.NLBHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateNLBHandler()!")
+	nlbHandler := ibmrs.IbmNLBHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		VpcService:     cloudConn.VpcService,
+		Ctx:            cloudConn.Ctx,
+		TaggingService: cloudConn.TaggingService,
+		SearchService:  cloudConn.SearchService,
+	}
+	return &nlbHandler, nil
+}
+
+func (cloudConn *IbmCloudConnection) IsConnected() (bool, error) {
+	cblogger.Info("Ibm Cloud Driver: called IsConnected()!")
+	return true, nil
+}
+func (cloudConn *IbmCloudConnection) Close() error {
+	cblogger.Info("Ibm Cloud Driver: called Close()!")
+	return nil
+}
+
+func (cloudConn *IbmCloudConnection) CreateDiskHandler() (irs.DiskHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateDiskHandler()!")
+	diskHandler := ibmrs.IbmDiskHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		VpcService:     cloudConn.VpcService,
+		Ctx:            cloudConn.Ctx,
+		TaggingService: cloudConn.TaggingService,
+		SearchService:  cloudConn.SearchService,
+	}
+	return &diskHandler, nil
+}
+
+func (cloudConn *IbmCloudConnection) CreateClusterHandler() (irs.ClusterHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateClusterHandler()!")
+	clusterHandler := ibmrs.IbmClusterHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		VpcService:     cloudConn.VpcService,
+		ClusterService: cloudConn.ClusterService,
+		Ctx:            cloudConn.Ctx,
+		TaggingService: cloudConn.TaggingService,
+		SearchService:  cloudConn.SearchService,
+	}
+	return &clusterHandler, nil
+}
+
+func (cloudConn *IbmCloudConnection) CreateMyImageHandler() (irs.MyImageHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateMyImageHandler()!")
+	myIamgeHandler := ibmrs.IbmMyImageHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		VpcService:     cloudConn.VpcService,
+		Ctx:            cloudConn.Ctx,
+		TaggingService: cloudConn.TaggingService,
+		SearchService:  cloudConn.SearchService,
+	}
+	return &myIamgeHandler, nil
+}
+
+func (cloudConn *IbmCloudConnection) CreateAnyCallHandler() (irs.AnyCallHandler, error) {
+	return nil, errors.New("Ibm Driver: not implemented")
+}
+
+func (cloudConn *IbmCloudConnection) CreateRegionZoneHandler() (irs.RegionZoneHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateRegionZoneHandler()!")
+	regionZoneHandler := ibmrs.IbmRegionZoneHandler{
+		Region:     cloudConn.Region,
+		VpcService: cloudConn.VpcService,
+		Ctx:        cloudConn.Ctx,
+	}
+	return &regionZoneHandler, nil
+}
+
+func (cloudConn *IbmCloudConnection) CreatePriceInfoHandler() (irs.PriceInfoHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreatePriceInfoHandler()!")
+	priceInfoHandler := ibmrs.IbmPriceInfoHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		VpcService:     cloudConn.VpcService,
+		Ctx:            cloudConn.Ctx,
+	}
+	return &priceInfoHandler, nil
+}
+
+func (cloudConn *IbmCloudConnection) CreateFileSystemHandler() (irs.FileSystemHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateFileSystemHandler()!")
+	priceInfoHandler := ibmrs.IbmFileSystemHandler{
+		Region:         cloudConn.Region,
+		CredentialInfo: cloudConn.CredentialInfo,
+		Ctx:            cloudConn.Ctx,
+		VpcService:     cloudConn.VpcService,
+		TaggingService: cloudConn.TaggingService,
+		SearchService:  cloudConn.SearchService,
+	}
+	return &priceInfoHandler, nil
+}
+
+func (cloudConn *IbmCloudConnection) CreateTagHandler() (irs.TagHandler, error) {
+	cblogger.Info("Ibm Cloud Driver: called CreateTagHandler()!")
+	TagHandler := ibmrs.IbmTagHandler{
+		Region:         cloudConn.Region,
+		CredentialInfo: cloudConn.CredentialInfo,
+		VpcService:     cloudConn.VpcService,
+		ClusterService: cloudConn.ClusterService,
+		Ctx:            cloudConn.Ctx,
+		TaggingService: cloudConn.TaggingService,
+		SearchService:  cloudConn.SearchService,
+	}
+	return &TagHandler, nil
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/kt/connect/KT_Connection.go b/cloud-control-manager/cloud-driver/drivers/kt/connect/KT_Connection.go
index 7f6894c4..ad7abca0 100644
--- a/cloud-control-manager/cloud-driver/drivers/kt/connect/KT_Connection.go
+++ b/cloud-control-manager/cloud-driver/drivers/kt/connect/KT_Connection.go
@@ -136,3 +136,7 @@ func (cloudConn *KTCloudVpcConnection) Close() error {
 func (cloudConn *KTCloudVpcConnection) CreateTagHandler() (irs.TagHandler, error) {
 	return nil, fmt.Errorf("KT Cloud VPC Driver: not implemented")
 }
+
+func (cloudConn *KTCloudVpcConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, fmt.Errorf("KT Cloud VPC Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/ktclassic/connect/KTClassic_Connection.go b/cloud-control-manager/cloud-driver/drivers/ktclassic/connect/KTClassic_Connection.go
index b219780c..dfa5ada3 100644
--- a/cloud-control-manager/cloud-driver/drivers/ktclassic/connect/KTClassic_Connection.go
+++ b/cloud-control-manager/cloud-driver/drivers/ktclassic/connect/KTClassic_Connection.go
@@ -12,6 +12,7 @@
 package connect
 
 import (
+	"errors"
 	"fmt"
 	"github.com/sirupsen/logrus"
 
@@ -146,3 +147,7 @@ func (cloudConn *KtCloudConnection) Close() error {
 	cblogger.Info("KT Cloud Driver: called Close()!")
 	return nil
 }
+
+func (cloudConn *KtCloudConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, errors.New("KT Cloud Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/mock/connect/MockCloudConnection.go b/cloud-control-manager/cloud-driver/drivers/mock/connect/MockCloudConnection.go
index ad6c9a4e..62eef661 100644
--- a/cloud-control-manager/cloud-driver/drivers/mock/connect/MockCloudConnection.go
+++ b/cloud-control-manager/cloud-driver/drivers/mock/connect/MockCloudConnection.go
@@ -1,6 +1,7 @@
 package connect
 
 import (
+	"errors"
 	cblog "github.com/cloud-barista/cb-log"
 	mkrs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/drivers/mock/resources"
 	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
@@ -123,3 +124,7 @@ func (cloudConn *MockConnection) CreateTagHandler() (irs.TagHandler, error) {
 	handler := mkrs.MockTagHandler{MockName: cloudConn.MockName}
 	return &handler, nil
 }
+
+func (cloudConn *MockConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, errors.New("Mock Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/ncp/connect/NcpVpcCloudConnection.go b/cloud-control-manager/cloud-driver/drivers/ncp/connect/NcpVpcCloudConnection.go
index 478afb8e..62c8aa0a 100644
--- a/cloud-control-manager/cloud-driver/drivers/ncp/connect/NcpVpcCloudConnection.go
+++ b/cloud-control-manager/cloud-driver/drivers/ncp/connect/NcpVpcCloudConnection.go
@@ -183,3 +183,7 @@ func (cloudConn *NcpVpcCloudConnection) CreateFileSystemHandler() (irs.FileSyste
 	cblogger.Info("NCP VPC Cloud Driver: called CreateFileSystemHandler()!")
 	return nil, fmt.Errorf("NCP VPC Cloud Driver: CreateFileSystemHandler is not implemented")
 }
+
+func (cloudConn *NcpVpcCloudConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, fmt.Errorf("NCP VPC Cloud Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/ncp/connect/NcpVpcCloudConnection.go.orig b/cloud-control-manager/cloud-driver/drivers/ncp/connect/NcpVpcCloudConnection.go.orig
new file mode 100644
index 00000000..478afb8e
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/drivers/ncp/connect/NcpVpcCloudConnection.go.orig
@@ -0,0 +1,185 @@
+// Proof of Concepts of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// This is a Cloud Driver Example for PoC Test.
+//
+// by ETRI, 2020.12.
+// by ETRI, 2022.10. updated
+
+package connect
+
+import (
+	"context"
+	"fmt"
+
+	"github.com/sirupsen/logrus"
+
+	cblog "github.com/cloud-barista/cb-log"
+	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
+	irs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+
+	vas "github.com/NaverCloudPlatform/ncloud-sdk-go-v2/services/vautoscaling"
+	vlb "github.com/NaverCloudPlatform/ncloud-sdk-go-v2/services/vloadbalancer"
+	vnks "github.com/NaverCloudPlatform/ncloud-sdk-go-v2/services/vnks"
+	vpc "github.com/NaverCloudPlatform/ncloud-sdk-go-v2/services/vpc"
+	vserver "github.com/NaverCloudPlatform/ncloud-sdk-go-v2/services/vserver"
+
+	// ncprs "github.com/cloud-barista/ncp/ncp/resources" // For local testing
+	ncprs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/drivers/ncp/resources"
+)
+
+type NcpVpcCloudConnection struct {
+	CredentialInfo idrv.CredentialInfo
+	RegionInfo     idrv.RegionInfo
+	VmClient       *vserver.APIClient
+	VpcClient      *vpc.APIClient
+	VlbClient      *vlb.APIClient
+	VnksClient     *vnks.APIClient
+	VasClient      *vas.APIClient
+}
+
+var cblogger *logrus.Logger
+
+func init() {
+	// cblog is a global variable.
+	cblogger = cblog.GetLogger("NCP VPC Connect")
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateVMHandler() (irs.VMHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateVMHandler()!")
+
+	//NOTE Just for Test!!
+	// cblogger.Info("cloudConn.CredentialInfo.ClientId : ")
+	// spew.Dump(cloudConn.CredentialInfo.ClientId)
+	// cblogger.Info("cloudConn.RegionInfo : ")
+	// spew.Dump(cloudConn.RegionInfo)
+
+	vmHandler := ncprs.NcpVpcVMHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		RegionInfo:     cloudConn.RegionInfo,
+		VMClient:       cloudConn.VmClient,
+	}
+
+	return &vmHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateVMSpecHandler()!")
+	vmspecHandler := ncprs.NcpVpcVMSpecHandler{CredentialInfo: cloudConn.CredentialInfo, RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VmClient}
+
+	return &vmspecHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateImageHandler() (irs.ImageHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateImagehandler()!")
+	imageHandler := ncprs.NcpVpcImageHandler{CredentialInfo: cloudConn.CredentialInfo, RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VmClient}
+
+	return &imageHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateKeyPairHandler()!")
+	keypairHandler := ncprs.NcpVpcKeyPairHandler{CredentialInfo: cloudConn.CredentialInfo, RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VmClient}
+
+	return &keypairHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateSecurityHandler()!")
+	sgHandler := ncprs.NcpVpcSecurityHandler{CredentialInfo: cloudConn.CredentialInfo, RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VmClient}
+
+	return &sgHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateVPCHandler()!")
+	vpcHandler := ncprs.NcpVpcVPCHandler{CredentialInfo: cloudConn.CredentialInfo, RegionInfo: cloudConn.RegionInfo, VPCClient: cloudConn.VpcClient}
+
+	return &vpcHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateNLBHandler() (irs.NLBHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateNLBHandler()!")
+	nlbHandler := ncprs.NcpVpcNLBHandler{CredentialInfo: cloudConn.CredentialInfo, RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VmClient, VPCClient: cloudConn.VpcClient, VLBClient: cloudConn.VlbClient}
+
+	return &nlbHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateDiskHandler() (irs.DiskHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateDiskHandler()!")
+	// cblogger.Info("\n### cloudConn.RegionInfo : ")
+	// spew.Dump(cloudConn.RegionInfo)
+	// cblogger.Info("\n")
+
+	diskHandler := ncprs.NcpVpcDiskHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VmClient}
+
+	return &diskHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateMyImageHandler() (irs.MyImageHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateMyImageHandler()!")
+	myimageHandler := ncprs.NcpVpcMyImageHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VmClient}
+
+	return &myimageHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateClusterHandler() (irs.ClusterHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateClusterHandler()!")
+
+	ctx := context.Background()
+	clusterHandler := ncprs.NcpVpcClusterHandler{
+		cloudConn.RegionInfo, ctx, cloudConn.VmClient, cloudConn.VpcClient,
+		cloudConn.VnksClient, cloudConn.VasClient}
+	return &clusterHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateAnyCallHandler() (irs.AnyCallHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateAnyCallHandler()!")
+
+	return nil, fmt.Errorf("NCP VPC Cloud Driver does not support CreateAnyCallHandler yet.")
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateRegionZoneHandler() (irs.RegionZoneHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateRegionZoneHandler()!")
+
+	regionZoneHandler := ncprs.NcpRegionZoneHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VmClient}
+	return &regionZoneHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreatePriceInfoHandler() (irs.PriceInfoHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreatePriceInfoHandler()!")
+
+	priceInfoHandler := ncprs.NcpVpcPriceInfoHandler{CredentialInfo: cloudConn.CredentialInfo, RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VmClient}
+	return &priceInfoHandler, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) IsConnected() (bool, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called IsConnected()!")
+	if cloudConn == nil {
+		return false, nil
+	}
+
+	if cloudConn.VmClient.V2Api == nil {
+		return false, nil
+	}
+
+	return true, nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) Close() error {
+	cblogger.Info("NCP VPC Cloud Driver: called Close()!")
+
+	return nil
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateTagHandler() (irs.TagHandler, error) {
+	return nil, fmt.Errorf("NCP VPC Cloud Driver: not implemented")
+}
+
+func (cloudConn *NcpVpcCloudConnection) CreateFileSystemHandler() (irs.FileSystemHandler, error) {
+	cblogger.Info("NCP VPC Cloud Driver: called CreateFileSystemHandler()!")
+	return nil, fmt.Errorf("NCP VPC Cloud Driver: CreateFileSystemHandler is not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/nhn/connect/NHN_CloudConnection.go b/cloud-control-manager/cloud-driver/drivers/nhn/connect/NHN_CloudConnection.go
index bb6bc668..bb1fd640 100644
--- a/cloud-control-manager/cloud-driver/drivers/nhn/connect/NHN_CloudConnection.go
+++ b/cloud-control-manager/cloud-driver/drivers/nhn/connect/NHN_CloudConnection.go
@@ -166,3 +166,7 @@ func (cloudConn *NhnCloudConnection) Close() error {
 func (cloudConn *NhnCloudConnection) CreateTagHandler() (irs.TagHandler, error) {
 	return nil, errors.New("NHN Cloud Driver: not implemented")
 }
+
+func (cloudConn *NhnCloudConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, fmt.Errorf("NHN Cloud Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/nhn/connect/NHN_CloudConnection.go.orig b/cloud-control-manager/cloud-driver/drivers/nhn/connect/NHN_CloudConnection.go.orig
new file mode 100644
index 00000000..bb6bc668
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/drivers/nhn/connect/NHN_CloudConnection.go.orig
@@ -0,0 +1,168 @@
+// Proof of Concepts of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// This is a Cloud Driver Example for PoC Test.
+//
+// by ETRI Team, 2021.12.
+// by ETRI Team, 2022.08.
+
+package connect
+
+import (
+	"errors"
+	"fmt"
+
+	// "github.com/davecgh/go-spew/spew"
+	"github.com/sirupsen/logrus"
+
+	cblog "github.com/cloud-barista/cb-log"
+	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
+	irs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+
+	nhnsdk "github.com/cloud-barista/nhncloud-sdk-go"
+
+	// nhnrs "github.com/cloud-barista/nhncloud/nhncloud/resources"
+	nhnrs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/drivers/nhn/resources"
+)
+
+var cblogger *logrus.Logger
+
+func init() {
+	// cblog is a global variable.
+	cblogger = cblog.GetLogger("CB-SPIDER")
+}
+
+type NhnCloudConnection struct {
+	CredentialInfo idrv.CredentialInfo
+	RegionInfo     idrv.RegionInfo
+	VMClient       *nhnsdk.ServiceClient
+	ImageClient    *nhnsdk.ServiceClient
+	NetworkClient  *nhnsdk.ServiceClient
+	VolumeClient   *nhnsdk.ServiceClient
+	ClusterClient  *nhnsdk.ServiceClient
+	FSClient       *nhnsdk.ServiceClient
+	NetworkClient1 *nhnsdk.ServiceClient
+}
+
+// CreateFileSystemHandler implements connect.CloudConnection.
+func (cloudConn *NhnCloudConnection) CreateFileSystemHandler() (irs.FileSystemHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateFileSystemHandler()!")
+	fileSystemHandler := nhnrs.NhnCloudFileSystemHandler{CredentialInfo: cloudConn.CredentialInfo, RegionInfo: cloudConn.RegionInfo, FSClient: cloudConn.FSClient, NetworkClient: cloudConn.NetworkClient}
+
+	return &fileSystemHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateVMHandler() (irs.VMHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateVMHandler()!")
+	vmHandler := nhnrs.NhnCloudVMHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VMClient, ImageClient: cloudConn.ImageClient, NetworkClient: cloudConn.NetworkClient, VolumeClient: cloudConn.VolumeClient}
+
+	return &vmHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateImageHandler() (irs.ImageHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateImageHandler()!")
+	imageHandler := nhnrs.NhnCloudImageHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VMClient, ImageClient: cloudConn.ImageClient}
+
+	return &imageHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateVMSpecHandler()!")
+	vmSpecHandler := nhnrs.NhnCloudVMSpecHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VMClient}
+
+	return &vmSpecHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateKeyPairHandler()!")
+	keypairHandler := nhnrs.NhnCloudKeyPairHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VMClient}
+
+	return &keypairHandler, nil
+}
+
+func (cloudConn NhnCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateSecurityHandler()!")
+	securityHandler := nhnrs.NhnCloudSecurityHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VMClient, NetworkClient: cloudConn.NetworkClient}
+
+	return &securityHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateVPCHandler()!")
+	vpcHandler := nhnrs.NhnCloudVPCHandler{CredentialInfo: cloudConn.CredentialInfo, RegionInfo: cloudConn.RegionInfo, NetworkClient: cloudConn.NetworkClient}
+
+	return &vpcHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateNLBHandler() (irs.NLBHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateNLBHandler()!")
+	nlbHandler := nhnrs.NhnCloudNLBHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VMClient, NetworkClient: cloudConn.NetworkClient} //Caution!! : No NLBClient
+
+	return &nlbHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateDiskHandler() (irs.DiskHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateDiskHandler()!")
+	diskHandler := nhnrs.NhnCloudDiskHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VMClient, VolumeClient: cloudConn.VolumeClient}
+
+	return &diskHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateClusterHandler() (irs.ClusterHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateClusterHandler()!")
+
+	if cloudConn.ClusterClient == nil {
+		// Some regions(ex. JPN) do not support a cluster service.
+		err := fmt.Errorf("ClusterClient is invalid, indicating that no suitable endpoint was found in the service catalog.")
+		return nil, err
+	}
+
+	clusterHandler := nhnrs.NhnCloudClusterHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VMClient, ImageClient: cloudConn.ImageClient, NetworkClient: cloudConn.NetworkClient, ClusterClient: cloudConn.ClusterClient}
+
+	return &clusterHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateMyImageHandler() (irs.MyImageHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateMyImageHandler()!")
+	myimageHandler := nhnrs.NhnCloudMyImageHandler{RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VMClient, ImageClient: cloudConn.ImageClient, NetworkClient: cloudConn.NetworkClient, VolumeClient: cloudConn.VolumeClient}
+
+	return &myimageHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateAnyCallHandler() (irs.AnyCallHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateAnyCallHandler()!")
+
+	return nil, fmt.Errorf("NHN Cloud Driver does not support CreateAnyCallHandler yet.")
+}
+
+func (cloudConn *NhnCloudConnection) CreateRegionZoneHandler() (irs.RegionZoneHandler, error) {
+	cblogger.Info("NNH cloud Driver: called CreateRegionZoneHandler()!")
+	regionZoneHandler := nhnrs.NhnCloudRegionZoneHandler{CredentialInfo: cloudConn.CredentialInfo, RegionInfo: cloudConn.RegionInfo, VMClient: cloudConn.VMClient}
+
+	return &regionZoneHandler, nil
+}
+
+func (cloudConn *NhnCloudConnection) CreatePriceInfoHandler() (irs.PriceInfoHandler, error) {
+
+	return nil, errors.New("NHN Cloud Driver: not implemented")
+}
+
+func (cloudConn *NhnCloudConnection) IsConnected() (bool, error) {
+	if cloudConn == nil {
+		return false, nil
+	}
+
+	return true, nil
+}
+
+func (cloudConn *NhnCloudConnection) Close() error {
+
+	return nil
+}
+
+func (cloudConn *NhnCloudConnection) CreateTagHandler() (irs.TagHandler, error) {
+	return nil, errors.New("NHN Cloud Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/openstack/connect/OpenStack_CloudConnection.go b/cloud-control-manager/cloud-driver/drivers/openstack/connect/OpenStack_CloudConnection.go
index 2e578268..113ca5d4 100644
--- a/cloud-control-manager/cloud-driver/drivers/openstack/connect/OpenStack_CloudConnection.go
+++ b/cloud-control-manager/cloud-driver/drivers/openstack/connect/OpenStack_CloudConnection.go
@@ -203,3 +203,7 @@ func (cloudConn *OpenStackCloudConnection) CreateFileSystemHandler() (irs.FileSy
 	}
 	return &fileSystemHandler, nil
 }
+
+func (cloudConn *OpenStackCloudConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, errors.New("OpenStack Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/openstack/connect/OpenStack_CloudConnection.go.orig b/cloud-control-manager/cloud-driver/drivers/openstack/connect/OpenStack_CloudConnection.go.orig
new file mode 100644
index 00000000..2e578268
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/drivers/openstack/connect/OpenStack_CloudConnection.go.orig
@@ -0,0 +1,205 @@
+// Proof of Concepts of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// This is a Cloud Driver Example for PoC Test.
+//
+// by CB-Spider Team, 2019.06.
+
+package connect
+
+import (
+	cblog "github.com/cloud-barista/cb-log"
+	"github.com/gophercloud/gophercloud"
+	"github.com/sirupsen/logrus"
+
+	osrs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/drivers/openstack/resources"
+	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
+	irs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+
+	"errors"
+)
+
+var cblogger *logrus.Logger
+
+func init() {
+	// cblog is a global variable.
+	cblogger = cblog.GetLogger("CB-SPIDER")
+}
+
+// OpenStackCloudConnection modified by powerkim, 2019.07.29
+type OpenStackCloudConnection struct {
+	CredentialInfo         idrv.CredentialInfo
+	Region                 idrv.RegionInfo
+	ComputeClient          *gophercloud.ServiceClient
+	ImageClient            *gophercloud.ServiceClient
+	NetworkClient          *gophercloud.ServiceClient
+	Volume2Client          *gophercloud.ServiceClient
+	Volume3Client          *gophercloud.ServiceClient
+	NLBClient              *gophercloud.ServiceClient
+	SharedFileSystemClient *gophercloud.ServiceClient
+	IdentityClient         *gophercloud.ServiceClient
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateImageHandler() (irs.ImageHandler, error) {
+	cblogger.Info("OpenStack Cloud Driver: called CreateImageHandler()!")
+	imageHandler := osrs.OpenStackImageHandler{Client: cloudConn.ComputeClient, ImageClient: cloudConn.ImageClient}
+	return &imageHandler, nil
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) {
+	cblogger.Info("OpenStack Cloud Driver: called CreateVPCHandler()!")
+	vpcHandler := osrs.OpenStackVPCHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		IdentityClient: cloudConn.IdentityClient,
+		ComputeClient:  cloudConn.ComputeClient,
+		NetworkClient:  cloudConn.NetworkClient,
+		NLBClient:      cloudConn.NLBClient,
+	}
+	return &vpcHandler, nil
+}
+
+func (cloudConn OpenStackCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) {
+	cblogger.Info("OpenStack Cloud Driver: called CreateSecurityHandler()!")
+	securityHandler := osrs.OpenStackSecurityHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		IdentityClient: cloudConn.IdentityClient,
+		ComputeClient:  cloudConn.ComputeClient,
+		NetworkClient:  cloudConn.NetworkClient,
+		NLBClient:      cloudConn.NLBClient,
+	}
+	return &securityHandler, nil
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) {
+	cblogger.Info("OpenStack Cloud Driver: called CreateKeyPairHandler()!")
+	keypairHandler := osrs.OpenStackKeyPairHandler{Client: cloudConn.ComputeClient}
+	return &keypairHandler, nil
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateVMHandler() (irs.VMHandler, error) {
+	cblogger.Info("OpenStack Cloud Driver: called CreateVMHandler()!")
+	vmHandler := osrs.OpenStackVMHandler{
+		Region:         cloudConn.Region,
+		CredentialInfo: cloudConn.CredentialInfo,
+		IdentityClient: cloudConn.IdentityClient,
+		ComputeClient:  cloudConn.ComputeClient,
+		NetworkClient:  cloudConn.NetworkClient,
+		NLBClient:      cloudConn.NLBClient,
+		VolumeClient:   cloudConn.Volume3Client,
+	}
+	if vmHandler.VolumeClient == nil {
+		vmHandler.VolumeClient = cloudConn.Volume2Client
+	}
+	return &vmHandler, nil
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) {
+	cblogger.Info("OpenStack Cloud Driver: called CreateVMSpecHandler()!")
+	vmSpecHandler := osrs.OpenStackVMSpecHandler{Region: cloudConn.Region, Client: cloudConn.ComputeClient}
+	return &vmSpecHandler, nil
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateNLBHandler() (irs.NLBHandler, error) {
+	cblogger.Info("OpenStack Cloud Driver: called CreateNLBHandler()!")
+	nlbHandler := osrs.OpenStackNLBHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		IdentityClient: cloudConn.IdentityClient,
+		ComputeClient:  cloudConn.ComputeClient,
+		NetworkClient:  cloudConn.NetworkClient,
+		NLBClient:      cloudConn.NLBClient,
+	}
+	return &nlbHandler, nil
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateDiskHandler() (irs.DiskHandler, error) {
+	cblogger.Info("OpenStack Driver: called CreateDiskHandler()!")
+	diskHandler := osrs.OpenstackDiskHandler{
+		CredentialInfo: cloudConn.CredentialInfo, Region: cloudConn.Region,
+		ComputeClient: cloudConn.ComputeClient,
+		VolumeClient:  cloudConn.Volume3Client,
+	}
+	if diskHandler.VolumeClient == nil {
+		diskHandler.VolumeClient = cloudConn.Volume2Client
+	}
+	return &diskHandler, nil
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateMyImageHandler() (irs.MyImageHandler, error) {
+	cblogger.Info("OpenStack Driver: called CreateMyImageHandler()!")
+
+	myImageHandler := osrs.OpenStackMyImageHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+		ComputeClient:  cloudConn.ComputeClient,
+		VolumeClient:   cloudConn.Volume3Client,
+	}
+	if myImageHandler.VolumeClient == nil {
+		myImageHandler.VolumeClient = cloudConn.Volume2Client
+	}
+	return &myImageHandler, nil
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateRegionZoneHandler() (irs.RegionZoneHandler, error) {
+	cblogger.Info("OpenStack Driver: called CreateRegionZoneHandler()!")
+
+	regionZoneHandler := osrs.OpenStackRegionZoneHandler{
+		Region:         cloudConn.Region,
+		IdentityClient: cloudConn.IdentityClient,
+	}
+	return &regionZoneHandler, nil
+}
+
+func (cloudConn *OpenStackCloudConnection) IsConnected() (bool, error) {
+	return true, nil
+}
+func (cloudConn *OpenStackCloudConnection) Close() error {
+	return nil
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateClusterHandler() (irs.ClusterHandler, error) {
+	return nil, errors.New("OpenStack Driver: not implemented")
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateAnyCallHandler() (irs.AnyCallHandler, error) {
+	cblogger.Info("OpenStack Driver: called CreateAnyCallHandler()!")
+
+	anyCallHandler := osrs.OpenStackAnyCallHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		Region:         cloudConn.Region,
+	}
+	return &anyCallHandler, nil
+}
+
+func (*OpenStackCloudConnection) CreatePriceInfoHandler() (irs.PriceInfoHandler, error) {
+	return nil, errors.New("OpenStack Driver: Price info is not available for OpenStack.")
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateTagHandler() (irs.TagHandler, error) {
+	cblogger.Info("OpenStack Driver: called CreateTagHandler()!")
+
+	tagHandler := osrs.OpenStackTagHandler{
+		CredentialInfo: cloudConn.CredentialInfo,
+		IdentityClient: cloudConn.IdentityClient,
+		ComputeClient:  cloudConn.ComputeClient,
+		NetworkClient:  cloudConn.NetworkClient,
+		NLBClient:      cloudConn.NLBClient,
+	}
+	return &tagHandler, nil
+}
+
+func (cloudConn *OpenStackCloudConnection) CreateFileSystemHandler() (irs.FileSystemHandler, error) {
+	cblogger.Info("OpenStack Driver: called CreateFileSystemHandler()!")
+
+	fileSystemHandler := osrs.OpenstackFileSystemHandler{
+		Region:                 cloudConn.Region,
+		CredentialInfo:         cloudConn.CredentialInfo,
+		SharedFileSystemClient: cloudConn.SharedFileSystemClient,
+		NetworkClient:          cloudConn.NetworkClient,
+		ComputeClient:          cloudConn.ComputeClient,
+	}
+	return &fileSystemHandler, nil
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/tencent/connect/TencentCloudConnection.go b/cloud-control-manager/cloud-driver/drivers/tencent/connect/TencentCloudConnection.go
index bfb02d47..ba99dae6 100644
--- a/cloud-control-manager/cloud-driver/drivers/tencent/connect/TencentCloudConnection.go
+++ b/cloud-control-manager/cloud-driver/drivers/tencent/connect/TencentCloudConnection.go
@@ -170,3 +170,7 @@ func (cloudConn *TencentCloudConnection) CreateTagHandler() (irs.TagHandler, err
 	}
 	return &handler, nil
 }
+
+func (cloudConn *TencentCloudConnection) CreateMonitoringHandler() (irs.MonitoringHandler, error) {
+	return nil, errors.New("Tencent Driver: not implemented")
+}
diff --git a/cloud-control-manager/cloud-driver/drivers/tencent/connect/TencentCloudConnection.go.orig b/cloud-control-manager/cloud-driver/drivers/tencent/connect/TencentCloudConnection.go.orig
new file mode 100644
index 00000000..bfb02d47
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/drivers/tencent/connect/TencentCloudConnection.go.orig
@@ -0,0 +1,172 @@
+// Tencent Driver of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//   - Cloud-Barista: https://github.com/cloud-barista
+//
+// This is Tencent Driver.
+//
+// by CB-Spider Team, 2022.09.
+
+package connect
+
+import (
+	cblog "github.com/cloud-barista/cb-log"
+	trs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/drivers/tencent/resources"
+	idrv "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces"
+	irs "github.com/cloud-barista/cb-spider/cloud-control-manager/cloud-driver/interfaces/resources"
+	"github.com/sirupsen/logrus"
+
+	cbs "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cbs/v20170312"
+	cfs "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cfs/v20190719"
+	clb "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/clb/v20180317"
+	cvm "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/cvm/v20170312"
+	tag "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/tag/v20180813"
+	vpc "github.com/tencentcloud/tencentcloud-sdk-go/tencentcloud/vpc/v20170312"
+
+	tke "github.com/tencentcloud/tencentcloud-sdk-go-intl-en/tencentcloud/tke/v20180525"
+
+	"errors"
+)
+
+type TencentCloudConnection struct {
+	CredentialInfo   idrv.CredentialInfo
+	Region           idrv.RegionInfo
+	VNetworkClient   *vpc.Client
+	NLBClient        *clb.Client
+	VMClient         *cvm.Client
+	KeyPairClient    *cvm.Client
+	ImageClient      *cvm.Client
+	SecurityClient   *vpc.Client
+	VmSpecClient     *cvm.Client
+	DiskClient       *cbs.Client
+	MyImageClient    *cvm.Client
+	RegionZoneClient *cvm.Client
+	TagClient        *tag.Client
+	ClusterClient    *tke.Client
+	FileSystemClient *cfs.Client
+}
+
+// CreateFileSystemHandler implements connect.CloudConnection.
+func (cloudConn *TencentCloudConnection) CreateFileSystemHandler() (irs.FileSystemHandler, error) {
+	cblogger.Info("Start CreateFileSystemHandler()")
+
+	fileSystemHandler := trs.TencentFileSystemHandler{Region: cloudConn.Region, CFSClient: cloudConn.FileSystemClient, VPCClient: cloudConn.VNetworkClient}
+
+	return &fileSystemHandler, nil
+}
+
+var cblogger *logrus.Logger
+
+func init() {
+	// cblog is a global variable.
+	cblogger = cblog.GetLogger("CB-SPIDER TencentCloudConnection")
+}
+
+func (cloudConn *TencentCloudConnection) CreateKeyPairHandler() (irs.KeyPairHandler, error) {
+	cblogger.Info("Start CreateKeyPairHandler()")
+
+	keyPairHandler := trs.TencentKeyPairHandler{Region: cloudConn.Region, Client: cloudConn.KeyPairClient}
+
+	return &keyPairHandler, nil
+}
+
+func (cloudConn *TencentCloudConnection) CreateVMHandler() (irs.VMHandler, error) {
+	cblogger.Info("Start CreateVMHandler()")
+
+	vmHandler := trs.TencentVMHandler{Region: cloudConn.Region, Client: cloudConn.VMClient, DiskClient: cloudConn.DiskClient, VPCClient: cloudConn.VNetworkClient}
+	return &vmHandler, nil
+}
+
+func (cloudConn *TencentCloudConnection) IsConnected() (bool, error) {
+	return true, nil
+}
+func (cloudConn *TencentCloudConnection) Close() error {
+	return nil
+}
+
+func (cloudConn *TencentCloudConnection) CreateVPCHandler() (irs.VPCHandler, error) {
+	cblogger.Info("Start")
+	handler := trs.TencentVPCHandler{Region: cloudConn.Region, Client: cloudConn.VNetworkClient}
+
+	return &handler, nil
+}
+
+func (cloudConn *TencentCloudConnection) CreateNLBHandler() (irs.NLBHandler, error) {
+	cblogger.Info("Start")
+	handler := trs.TencentNLBHandler{Region: cloudConn.Region, Client: cloudConn.NLBClient, VpcClient: cloudConn.VNetworkClient}
+
+	return &handler, nil
+}
+
+func (cloudConn *TencentCloudConnection) CreateImageHandler() (irs.ImageHandler, error) {
+	cblogger.Info("Start")
+	handler := trs.TencentImageHandler{Region: cloudConn.Region, Client: cloudConn.ImageClient}
+
+	return &handler, nil
+}
+
+func (cloudConn *TencentCloudConnection) CreateSecurityHandler() (irs.SecurityHandler, error) {
+	cblogger.Info("Start")
+	handler := trs.TencentSecurityHandler{Region: cloudConn.Region, Client: cloudConn.SecurityClient, TagClient: cloudConn.TagClient}
+
+	return &handler, nil
+}
+
+func (cloudConn *TencentCloudConnection) CreateVMSpecHandler() (irs.VMSpecHandler, error) {
+	cblogger.Info("Start")
+	handler := trs.TencentVmSpecHandler{Region: cloudConn.Region, Client: cloudConn.VmSpecClient}
+	return &handler, nil
+}
+
+func (cloudConn *TencentCloudConnection) CreateDiskHandler() (irs.DiskHandler, error) {
+
+	cblogger.Info("Start")
+	handler := trs.TencentDiskHandler{Region: cloudConn.Region, Client: cloudConn.DiskClient}
+
+	return &handler, nil
+}
+
+func (cloudConn *TencentCloudConnection) CreateMyImageHandler() (irs.MyImageHandler, error) {
+	cblogger.Info("Start")
+	handler := trs.TencentMyImageHandler{Region: cloudConn.Region, Client: cloudConn.MyImageClient, CbsClient: cloudConn.DiskClient}
+
+	return &handler, nil
+}
+
+func (cloudConn *TencentCloudConnection) CreateClusterHandler() (irs.ClusterHandler, error) {
+	// temp
+	// getEnv & Setting
+	clusterHandler := trs.TencentClusterHandler{RegionInfo: cloudConn.Region, CredentialInfo: cloudConn.CredentialInfo}
+
+	return &clusterHandler, nil
+
+}
+
+func (cloudConn *TencentCloudConnection) CreateAnyCallHandler() (irs.AnyCallHandler, error) {
+	return nil, errors.New("Tencent Driver: not implemented")
+}
+
+func (cloudConn *TencentCloudConnection) CreateRegionZoneHandler() (irs.RegionZoneHandler, error) {
+	handler := trs.TencentRegionZoneHandler{Region: cloudConn.Region, Client: cloudConn.RegionZoneClient}
+	return &handler, nil
+}
+
+func (cloudConn *TencentCloudConnection) CreatePriceInfoHandler() (irs.PriceInfoHandler, error) {
+	handler := trs.TencentPriceInfoHandler{Region: cloudConn.Region, Client: cloudConn.VMClient}
+	return &handler, nil
+}
+
+func (cloudConn *TencentCloudConnection) CreateTagHandler() (irs.TagHandler, error) {
+	handler := trs.TencentTagHandler{
+		Region:    cloudConn.Region,
+		TagClient: cloudConn.TagClient,
+		// below client is for validate resources
+		VNetworkClient: cloudConn.VNetworkClient,
+		VMClient:       cloudConn.VMClient,
+		NLBClient:      cloudConn.NLBClient,
+		DiskClient:     cloudConn.DiskClient,
+		ClusterClient:  cloudConn.ClusterClient,
+	}
+	return &handler, nil
+}
diff --git a/cloud-control-manager/cloud-driver/interfaces/connect/CloudConnect.go b/cloud-control-manager/cloud-driver/interfaces/connect/CloudConnect.go
index c00dec51..717713a6 100644
--- a/cloud-control-manager/cloud-driver/interfaces/connect/CloudConnect.go
+++ b/cloud-control-manager/cloud-driver/interfaces/connect/CloudConnect.go
@@ -23,6 +23,7 @@ type CloudConnection interface {
 	CreateSecurityHandler() (irs.SecurityHandler, error)
 	CreateKeyPairHandler() (irs.KeyPairHandler, error)
 	CreateVMHandler() (irs.VMHandler, error)
+	CreateMonitoringHandler() (irs.MonitoringHandler, error)
 
 	CreateNLBHandler() (irs.NLBHandler, error)
 	CreateDiskHandler() (irs.DiskHandler, error)
diff --git a/cloud-control-manager/cloud-driver/interfaces/resources/MonitoringHandler.go b/cloud-control-manager/cloud-driver/interfaces/resources/MonitoringHandler.go
new file mode 100644
index 00000000..e32a3061
--- /dev/null
+++ b/cloud-control-manager/cloud-driver/interfaces/resources/MonitoringHandler.go
@@ -0,0 +1,85 @@
+// Cloud Driver Interface of CB-Spider.
+// The CB-Spider is a sub-Framework of the Cloud-Barista Multi-Cloud Project.
+// The CB-Spider Mission is to connect all the clouds with a single interface.
+//
+//      * Cloud-Barista: https://github.com/cloud-barista
+//
+// This is Resouces interfaces of Cloud Driver.
+//
+// by CB-Spider Team, 2020.04.
+// by CB-Spider Team, 2019.06.
+
+package resources
+
+import (
+	"time"
+)
+
+type VMMonitoringReqInfo struct {
+	VMIID          IID
+	MetricType     MetricType
+	IntervalMinute string
+	TimeBeforeHour string
+}
+
+type ClusterNodeMonitoringReqInfo struct {
+	ClusterIID     IID
+	NodeGroupID    IID
+	NodeIID        IID
+	MetricType     MetricType
+	IntervalMinute string
+	TimeBeforeHour string
+}
+
+type TimestampValue struct {
+	Timestamp time.Time `json:"timestamp"`
+	Value     string    `json:"value"`
+}
+
+type MetricData struct {
+	MetricName      string           `json:"metricName"`
+	MetricUnit      string           `json:"metricUnit"`
+	TimestampValues []TimestampValue `json:"timestampValues"`
+}
+
+type MetricType string
+
+const (
+	CPUUsage     MetricType = "cpu_usage"
+	MemoryUsage  MetricType = "memory_usage"
+	DiskRead     MetricType = "disk_read"
+	DiskWrite    MetricType = "disk_write"
+	DiskReadOps  MetricType = "disk_read_ops"
+	DiskWriteOps MetricType = "disk_write_ops"
+	NetworkIn    MetricType = "network_in"
+	NetworkOut   MetricType = "network_out"
+	Unknown      MetricType = "unknown"
+)
+
+func StringMetricType(input string) MetricType {
+	switch input {
+	case "cpu_usage":
+		return CPUUsage
+	case "memory_usage":
+		return MemoryUsage
+	case "disk_read":
+		return DiskRead
+	case "disk_write":
+		return DiskWrite
+	case "disk_read_ops":
+		return DiskReadOps
+	case "disk_write_ops":
+		return DiskWriteOps
+	case "network_in":
+		return NetworkIn
+	case "network_out":
+		return NetworkOut
+	default:
+		return Unknown
+	}
+}
+
+type MonitoringHandler interface {
+	GetVMMetricData(vmMonitoringReqInfo VMMonitoringReqInfo) (MetricData, error)
+	GetClusterNodeMetricData(clusterMonitoringReqInfo ClusterNodeMonitoringReqInfo) (MetricData, error)
+}
diff --git a/cloud-control-manager/cloud-driver/interfaces/resources/ResourceType.go b/cloud-control-manager/cloud-driver/interfaces/resources/ResourceType.go
index 5639ddad..09b27c42 100644
--- a/cloud-control-manager/cloud-driver/interfaces/resources/ResourceType.go
+++ b/cloud-control-manager/cloud-driver/interfaces/resources/ResourceType.go
@@ -18,18 +18,19 @@ import (
 type RSType string
 
 const (
-	ALL       RSType = "all"
-	IMAGE     RSType = "image"
-	VPC       RSType = "vpc"
-	SUBNET    RSType = "subnet"
-	SG        RSType = "sg"
-	KEY       RSType = "keypair"
-	VM        RSType = "vm"
-	NLB       RSType = "nlb"
-	DISK      RSType = "disk"
-	MYIMAGE   RSType = "myimage"
-	CLUSTER   RSType = "cluster"
-	NODEGROUP RSType = "nodegroup"
+	ALL          RSType = "all"
+	IMAGE        RSType = "image"
+	VPC          RSType = "vpc"
+	SUBNET       RSType = "subnet"
+	SG           RSType = "sg"
+	KEY          RSType = "keypair"
+	VM           RSType = "vm"
+	VMMONITORING RSType = "vmmonitoring"
+	NLB          RSType = "nlb"
+	DISK         RSType = "disk"
+	MYIMAGE      RSType = "myimage"
+	CLUSTER      RSType = "cluster"
+	NODEGROUP    RSType = "nodegroup"
 
 	FILESYSTEM RSType = "filesystem"
 )
